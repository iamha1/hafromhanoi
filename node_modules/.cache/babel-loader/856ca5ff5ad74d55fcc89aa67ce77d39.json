{"ast":null,"code":"function _extends() {\n  _extends = Object.assign || function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n\n    return target;\n  };\n\n  return _extends.apply(this, arguments);\n}\n\nfunction _inheritsLoose(subClass, superClass) {\n  subClass.prototype = Object.create(superClass.prototype);\n  subClass.prototype.constructor = subClass;\n\n  _setPrototypeOf(subClass, superClass);\n}\n\nfunction _getPrototypeOf(o) {\n  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {\n    return o.__proto__ || Object.getPrototypeOf(o);\n  };\n  return _getPrototypeOf(o);\n}\n\nfunction _setPrototypeOf(o, p) {\n  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {\n    o.__proto__ = p;\n    return o;\n  };\n\n  return _setPrototypeOf(o, p);\n}\n\nfunction _isNativeReflectConstruct() {\n  if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n  if (Reflect.construct.sham) return false;\n  if (typeof Proxy === \"function\") return true;\n\n  try {\n    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\n\nfunction _construct(Parent, args, Class) {\n  if (_isNativeReflectConstruct()) {\n    _construct = Reflect.construct;\n  } else {\n    _construct = function _construct(Parent, args, Class) {\n      var a = [null];\n      a.push.apply(a, args);\n      var Constructor = Function.bind.apply(Parent, a);\n      var instance = new Constructor();\n      if (Class) _setPrototypeOf(instance, Class.prototype);\n      return instance;\n    };\n  }\n\n  return _construct.apply(null, arguments);\n}\n\nfunction _isNativeFunction(fn) {\n  return Function.toString.call(fn).indexOf(\"[native code]\") !== -1;\n}\n\nfunction _wrapNativeSuper(Class) {\n  var _cache = typeof Map === \"function\" ? new Map() : undefined;\n\n  _wrapNativeSuper = function _wrapNativeSuper(Class) {\n    if (Class === null || !_isNativeFunction(Class)) return Class;\n\n    if (typeof Class !== \"function\") {\n      throw new TypeError(\"Super expression must either be null or a function\");\n    }\n\n    if (typeof _cache !== \"undefined\") {\n      if (_cache.has(Class)) return _cache.get(Class);\n\n      _cache.set(Class, Wrapper);\n    }\n\n    function Wrapper() {\n      return _construct(Class, arguments, _getPrototypeOf(this).constructor);\n    }\n\n    Wrapper.prototype = Object.create(Class.prototype, {\n      constructor: {\n        value: Wrapper,\n        enumerable: false,\n        writable: true,\n        configurable: true\n      }\n    });\n    return _setPrototypeOf(Wrapper, Class);\n  };\n\n  return _wrapNativeSuper(Class);\n}\n/**\n * Ported from https://github.com/sunnylqm/react-native-storage\n * Credit: Sunny Luo /sunnylqm\n */\n\n/**\n * Created by sunny on 9/1/16.\n */\n\n\nvar NotFoundError = /*#__PURE__*/function (_Error) {\n  _inheritsLoose(NotFoundError, _Error);\n\n  function NotFoundError(message) {\n    var _this;\n\n    _this = _Error.call(this, \"Not Found! Params: \" + message) || this;\n    _this.name = 'NotFoundError';\n    _this.stack = new Error().stack; // Optional\n\n    return _this;\n  }\n\n  return NotFoundError;\n}( /*#__PURE__*/_wrapNativeSuper(Error)); // NotFoundError.prototype = Object.create(Error.prototype);\n\n\nvar ExpiredError = /*#__PURE__*/function (_Error2) {\n  _inheritsLoose(ExpiredError, _Error2);\n\n  function ExpiredError(message) {\n    var _this2;\n\n    _this2 = _Error2.call(this, \"Expired! Params: \" + message) || this;\n    _this2.name = 'ExpiredError';\n    _this2.stack = new Error().stack; // Optional\n\n    return _this2;\n  }\n\n  return ExpiredError;\n}( /*#__PURE__*/_wrapNativeSuper(Error));\n\nvar Storage = /*#__PURE__*/function () {\n  function Storage(options) {\n    var _this = this;\n\n    if (options === void 0) {\n      options = {};\n    }\n\n    this._SIZE = options.size || 1000; // maximum key-ids capacity\n\n    this.sync = options.sync || {}; // remote sync method\n\n    this.defaultExpires = options.defaultExpires !== undefined ? options.defaultExpires : 1000 * 3600 * 24;\n    this.enableCache = options.enableCache !== false;\n    this._s = options.storageBackend || null;\n    this._innerVersion = 11;\n    this.cache = {};\n\n    if (this._s && this._s.setItem) {\n      try {\n        var promiseTest = this._s.setItem('__react_native_storage_test', 'test');\n\n        this.isPromise = !!(promiseTest && promiseTest.then);\n      } catch (e) {\n        console.warn(e);\n        delete this._s;\n        throw e;\n      }\n    } else {\n      console.warn(\"Data would be lost after reload cause there is no storageBackend specified!\\n      \\nEither use localStorage(for web) or AsyncStorage(for React Native) as a storageBackend.\");\n    }\n\n    this._mapPromise = this.getItem('map').then(function (map) {\n      _this._m = _this._checkMap(map && JSON.parse(map) || {});\n    });\n  }\n\n  var _proto = Storage.prototype;\n\n  _proto.getItem = function getItem(key) {\n    return this._s ? this.isPromise ? this._s.getItem(key) : Promise.resolve(this._s.getItem(key)) : Promise.resolve();\n  };\n\n  _proto.setItem = function setItem(key, value) {\n    return this._s ? this.isPromise ? this._s.setItem(key, value) : Promise.resolve(this._s.setItem(key, value)) : Promise.resolve();\n  };\n\n  _proto.removeItem = function removeItem(key) {\n    return this._s ? this.isPromise ? this._s.removeItem(key) : Promise.resolve(this._s.removeItem(key)) : Promise.resolve();\n  };\n\n  _proto._initMap = function _initMap() {\n    return {\n      innerVersion: this._innerVersion,\n      index: 0,\n      __keys__: {}\n    };\n  };\n\n  _proto._checkMap = function _checkMap(map) {\n    if (map && map.innerVersion && map.innerVersion === this._innerVersion) {\n      return map;\n    } else {\n      return this._initMap();\n    }\n  };\n\n  _proto._getId = function _getId(key, id) {\n    return key + '_' + id;\n  };\n\n  _proto._saveToMap = function _saveToMap(params) {\n    var key = params.key,\n        id = params.id,\n        data = params.data,\n        newId = this._getId(key, id),\n        m = this._m;\n\n    if (m[newId] !== undefined) {\n      // update existing data\n      if (this.enableCache) this.cache[newId] = JSON.parse(data);\n      return this.setItem('map_' + m[newId], data);\n    }\n\n    if (m[m.index] !== undefined) {\n      // loop over, delete old data\n      var oldId = m[m.index];\n      var splitOldId = oldId.split('_');\n      delete m[oldId];\n\n      this._removeIdInKey(splitOldId[0], splitOldId[1]);\n\n      if (this.enableCache) {\n        delete this.cache[oldId];\n      }\n    }\n\n    m[newId] = m.index;\n    m[m.index] = newId;\n    m.__keys__[key] = m.__keys__[key] || [];\n\n    m.__keys__[key].push(id);\n\n    if (this.enableCache) {\n      var cacheData = JSON.parse(data);\n      this.cache[newId] = cacheData;\n    }\n\n    var currentIndex = m.index;\n\n    if (++m.index === this._SIZE) {\n      m.index = 0;\n    }\n\n    this.setItem('map_' + currentIndex, data);\n    this.setItem('map', JSON.stringify(m));\n  };\n\n  _proto.save = function save(params) {\n    var _this2 = this;\n\n    var key = params.key,\n        id = params.id,\n        data = params.data,\n        rawData = params.rawData,\n        _params$expires = params.expires,\n        expires = _params$expires === void 0 ? this.defaultExpires : _params$expires;\n\n    if (key.toString().indexOf('_') !== -1) {\n      console.error('Please do not use \"_\" in key!');\n    }\n\n    var dataToSave = {\n      rawData: data\n    };\n\n    if (data === undefined) {\n      if (rawData !== undefined) {\n        console.warn('\"rawData\" is deprecated, please use \"data\" instead!');\n        dataToSave.rawData = rawData;\n      } else {\n        console.error('\"data\" is required in save()!');\n        return;\n      }\n    }\n\n    var now = Date.now();\n\n    if (expires !== null) {\n      dataToSave.expires = now + expires;\n    }\n\n    dataToSave = JSON.stringify(dataToSave);\n\n    if (id === undefined) {\n      if (this.enableCache) {\n        var cacheData = JSON.parse(dataToSave);\n        this.cache[key] = cacheData;\n      }\n\n      return this.setItem(key, dataToSave);\n    } else {\n      if (id.toString().indexOf('_') !== -1) {\n        console.error('Please do not use \"_\" in id!');\n      }\n\n      return this._mapPromise.then(function () {\n        return _this2._saveToMap({\n          key: key,\n          id: id,\n          data: dataToSave\n        });\n      });\n    }\n  };\n\n  _proto.getBatchData = function getBatchData(querys) {\n    var _this3 = this;\n\n    return Promise.all(querys.map(function (query) {\n      return _this3.load(query);\n    }));\n  };\n\n  _proto.getBatchDataWithIds = function getBatchDataWithIds(params) {\n    try {\n      var _this5 = this;\n\n      var key = params.key,\n          ids = params.ids,\n          syncInBackground = params.syncInBackground,\n          syncParams = params.syncParams;\n      var tasks = ids.map(function (id) {\n        return _this5.load({\n          key: key,\n          id: id,\n          syncInBackground: syncInBackground,\n          autoSync: false,\n          batched: true\n        });\n      });\n      return Promise.resolve(Promise.all(tasks)).then(function (results) {\n        var missingIds = [];\n        results.forEach(function (value) {\n          if (value.syncId !== undefined) {\n            missingIds.push(value.syncId);\n          }\n        });\n\n        if (missingIds.length) {\n          return Promise.resolve(_this5.sync[key]({\n            id: missingIds,\n            syncParams: syncParams\n          })).then(function (syncData) {\n            return results.map(function (value) {\n              return value.syncId ? syncData.shift() : value;\n            });\n          });\n        } else {\n          return results;\n        }\n      });\n    } catch (e) {\n      return Promise.reject(e);\n    }\n  };\n\n  _proto._lookupGlobalItem = function _lookupGlobalItem(params) {\n    var _this6 = this;\n\n    var key = params.key;\n\n    if (this.enableCache && this.cache[key] !== undefined) {\n      return this._loadGlobalItem(_extends({\n        ret: this.cache[key]\n      }, params));\n    }\n\n    return this.getItem(key).then(function (ret) {\n      return _this6._loadGlobalItem(_extends({\n        ret: ret\n      }, params));\n    });\n  };\n\n  _proto._loadGlobalItem = function _loadGlobalItem(params) {\n    var key = params.key,\n        ret = params.ret,\n        autoSync = params.autoSync,\n        syncInBackground = params.syncInBackground,\n        syncParams = params.syncParams;\n\n    if (ret === null || ret === undefined) {\n      if (autoSync && this.sync[key]) {\n        return this.sync[key]({\n          syncParams: syncParams\n        });\n      }\n\n      throw new NotFoundError(JSON.stringify(params));\n    }\n\n    if (typeof ret === 'string') {\n      ret = JSON.parse(ret);\n\n      if (this.enableCache) {\n        this.cache[key] = ret;\n      }\n    }\n\n    var now = Date.now();\n\n    if (ret.expires < now) {\n      if (autoSync && this.sync[key]) {\n        if (syncInBackground) {\n          try {\n            this.sync[key]({\n              syncParams: syncParams,\n              syncInBackground: syncInBackground\n            });\n          } catch (e) {// avoid uncaught exception\n          }\n\n          return ret.rawData;\n        }\n\n        return this.sync[key]({\n          syncParams: syncParams,\n          syncInBackground: syncInBackground\n        });\n      }\n\n      throw new ExpiredError(JSON.stringify(params));\n    }\n\n    return ret.rawData;\n  };\n\n  _proto._noItemFound = function _noItemFound(params) {\n    var key = params.key,\n        id = params.id,\n        autoSync = params.autoSync,\n        syncParams = params.syncParams;\n\n    if (this.sync[key]) {\n      if (autoSync) {\n        return this.sync[key]({\n          id: id,\n          syncParams: syncParams\n        });\n      }\n\n      return {\n        syncId: id\n      };\n    }\n\n    throw new NotFoundError(JSON.stringify(params));\n  };\n\n  _proto._loadMapItem = function _loadMapItem(params) {\n    var ret = params.ret,\n        key = params.key,\n        id = params.id,\n        autoSync = params.autoSync,\n        batched = params.batched,\n        syncInBackground = params.syncInBackground,\n        syncParams = params.syncParams;\n\n    if (ret === null || ret === undefined) {\n      return this._noItemFound(params);\n    }\n\n    if (typeof ret === 'string') {\n      ret = JSON.parse(ret);\n      var _key = params.key,\n          _id = params.id;\n\n      var newId = this._getId(_key, _id);\n\n      if (this.enableCache) {\n        this.cache[newId] = ret;\n      }\n    }\n\n    var now = Date.now();\n\n    if (ret.expires < now) {\n      if (autoSync && this.sync[key]) {\n        if (syncInBackground) {\n          try {\n            this.sync[key]({\n              id: id,\n              syncParams: syncParams,\n              syncInBackground: syncInBackground\n            });\n          } catch (e) {// avoid uncaught exception\n          }\n\n          return ret.rawData;\n        }\n\n        return this.sync[key]({\n          id: id,\n          syncParams: syncParams,\n          syncInBackground: syncInBackground\n        });\n      }\n\n      if (batched) {\n        return {\n          syncId: id\n        };\n      }\n\n      throw new ExpiredError(JSON.stringify(params));\n    }\n\n    return ret.rawData;\n  };\n\n  _proto._lookUpInMap = function _lookUpInMap(params) {\n    var _this7 = this;\n\n    var ret;\n    var m = this._m;\n    var key = params.key,\n        id = params.id;\n\n    var newId = this._getId(key, id);\n\n    if (this.enableCache && this.cache[newId]) {\n      ret = this.cache[newId];\n      return this._loadMapItem(_extends({\n        ret: ret\n      }, params));\n    }\n\n    if (m[newId] !== undefined) {\n      return this.getItem('map_' + m[newId]).then(function (ret) {\n        return _this7._loadMapItem(_extends({\n          ret: ret\n        }, params));\n      });\n    }\n\n    return this._noItemFound(_extends({\n      ret: ret\n    }, params));\n  };\n\n  _proto.remove = function remove(params) {\n    var _this8 = this;\n\n    return this._mapPromise.then(function () {\n      var m = _this8._m;\n      var key = params.key,\n          id = params.id;\n\n      if (id === undefined) {\n        if (_this8.enableCache && _this8.cache[key]) {\n          delete _this8.cache[key];\n        }\n\n        return _this8.removeItem(key);\n      }\n\n      var newId = _this8._getId(key, id); // remove existing data\n\n\n      if (m[newId] !== undefined) {\n        if (_this8.enableCache && _this8.cache[newId]) {\n          delete _this8.cache[newId];\n        }\n\n        _this8._removeIdInKey(key, id);\n\n        var idTobeDeleted = m[newId];\n        delete m[newId];\n\n        _this8.setItem('map', JSON.stringify(m));\n\n        return _this8.removeItem('map_' + idTobeDeleted);\n      }\n    });\n  };\n\n  _proto._removeIdInKey = function _removeIdInKey(key, id) {\n    var indexTobeRemoved = (this._m.__keys__[key] || []).indexOf(id);\n\n    if (indexTobeRemoved !== -1) {\n      this._m.__keys__[key].splice(indexTobeRemoved, 1);\n    }\n  };\n\n  _proto.load = function load(params) {\n    var _this9 = this;\n\n    var key = params.key,\n        id = params.id,\n        _params$autoSync = params.autoSync,\n        autoSync = _params$autoSync === void 0 ? true : _params$autoSync,\n        _params$syncInBackgro = params.syncInBackground,\n        syncInBackground = _params$syncInBackgro === void 0 ? true : _params$syncInBackgro,\n        syncParams = params.syncParams,\n        batched = params.batched;\n    return this._mapPromise.then(function () {\n      if (id === undefined) {\n        return _this9._lookupGlobalItem({\n          key: key,\n          autoSync: autoSync,\n          syncInBackground: syncInBackground,\n          syncParams: syncParams\n        });\n      } else {\n        return _this9._lookUpInMap({\n          key: key,\n          id: id,\n          autoSync: autoSync,\n          syncInBackground: syncInBackground,\n          batched: batched,\n          syncParams: syncParams\n        });\n      }\n    });\n  };\n\n  _proto.clearAll = function clearAll() {\n    this._s.clear && this._s.clear();\n    this._m = this._initMap();\n  };\n\n  _proto.clearMap = function clearMap() {\n    var _this10 = this;\n\n    return this.removeItem('map').then(function () {\n      _this10.cache = {};\n      _this10._m = _this10._initMap();\n    });\n  };\n\n  _proto.clearMapForKey = function clearMapForKey(key) {\n    var _this11 = this;\n\n    return this._mapPromise.then(function () {\n      var tasks = (_this11._m.__keys__[key] || []).map(function (id) {\n        return _this11.remove({\n          key: key,\n          id: id\n        });\n      });\n      return Promise.all(tasks);\n    });\n  };\n\n  _proto.getIdsForKey = function getIdsForKey(key) {\n    var _this12 = this;\n\n    return this._mapPromise.then(function () {\n      return _this12._m.__keys__[key] || [];\n    });\n  };\n\n  _proto.getAllDataForKey = function getAllDataForKey(key, options) {\n    var _this13 = this;\n\n    options = Object.assign({\n      syncInBackground: true\n    }, options);\n    return this.getIdsForKey(key).then(function (ids) {\n      var querys = ids.map(function (id) {\n        return {\n          key: key,\n          id: id,\n          syncInBackground: options.syncInBackground\n        };\n      });\n      return _this13.getBatchData(querys);\n    });\n  };\n\n  return Storage;\n}(); // https://github.com/sunnylqm/react-native-storage\n\n\nfunction _catch(body, recover) {\n  try {\n    var result = body();\n  } catch (e) {\n    return recover(e);\n  }\n\n  if (result && result.then) {\n    return result.then(void 0, recover);\n  }\n\n  return result;\n}\n\nvar setCacheTokens = function setCacheTokens(g, cookieName) {\n  try {\n    return Promise.resolve(storage.save({\n      key: cookieName + \"token\",\n      data: g.token,\n      expires: 3600 * 1000 * 24\n    })).then(function () {\n      return Promise.resolve(storage.save({\n        key: cookieName + \"refreshToken\",\n        data: g.refreshToken,\n        expires: 3600 * 1000 * 24\n      })).then(function () {\n        return Promise.resolve(storage.save({\n          key: cookieName + \"session\",\n          data: g.session,\n          expires: null\n        })).then(function () {});\n      });\n    });\n  } catch (e) {\n    return Promise.reject(e);\n  }\n};\n\nvar clearCacheTokens = function clearCacheTokens(cookieName) {\n  try {\n    return Promise.resolve(storage.remove({\n      key: cookieName + \"token\"\n    })).then(function () {\n      return Promise.resolve(storage.remove({\n        key: cookieName + \"refreshToken\"\n      })).then(function () {\n        return Promise.resolve(storage.remove({\n          key: cookieName + \"session\"\n        })).then(function () {});\n      });\n    });\n  } catch (e) {\n    return Promise.reject(e);\n  }\n};\n\nvar getCacheTokens = function getCacheTokens(cookieName) {\n  try {\n    var _temp7 = function _temp7() {\n      function _temp4() {\n        function _temp2() {\n          return {\n            cacheToken: cacheToken,\n            cacheRefreshToken: cacheRefreshToken,\n            cacheSession: cacheSession\n          };\n        }\n\n        var _temp = _catch(function () {\n          return Promise.resolve(storage.load({\n            key: cookieName + \"session\"\n          })).then(function (_storage$load3) {\n            cacheSession = _storage$load3;\n          });\n        }, function () {});\n\n        return _temp && _temp.then ? _temp.then(_temp2) : _temp2(_temp);\n      }\n\n      var _temp3 = _catch(function () {\n        return Promise.resolve(storage.load({\n          key: cookieName + \"refreshToken\"\n        })).then(function (_storage$load2) {\n          cacheRefreshToken = _storage$load2;\n        });\n      }, function () {});\n\n      return _temp3 && _temp3.then ? _temp3.then(_temp4) : _temp4(_temp3);\n    };\n\n    var cacheToken = false;\n    var cacheRefreshToken = false;\n    var cacheSession = false;\n\n    var _temp8 = _catch(function () {\n      return Promise.resolve(storage.load({\n        key: cookieName + \"token\"\n      })).then(function (_storage$load) {\n        cacheToken = _storage$load;\n      });\n    }, function () {});\n\n    return Promise.resolve(_temp8 && _temp8.then ? _temp8.then(_temp7) : _temp7(_temp8));\n  } catch (e) {\n    return Promise.reject(e);\n  }\n};\n\nvar storage = new Storage({\n  storageBackend: window.localStorage\n});\nexports.clearCacheTokens = clearCacheTokens;\nexports.getCacheTokens = getCacheTokens;\nexports.setCacheTokens = setCacheTokens;","map":{"version":3,"sources":["../src/storage/error.js","../src/storage/index.js","../src/cache.ts"],"names":["NotFoundError","ExpiredError","Storage","options","promiseTest","console","map","JSON","getItem","Promise","setItem","removeItem","_initMap","innerVersion","index","__keys__","_checkMap","_getId","key","_saveToMap","id","data","params","newId","m","oldId","splitOldId","cacheData","currentIndex","save","rawData","expires","dataToSave","now","Date","getBatchData","getBatchDataWithIds","ids","syncInBackground","syncParams","tasks","autoSync","batched","missingIds","results","value","syncData","_lookupGlobalItem","ret","_loadGlobalItem","_noItemFound","syncId","_loadMapItem","_lookUpInMap","remove","idTobeDeleted","_removeIdInKey","indexTobeRemoved","load","clearAll","clearMap","clearMapForKey","getIdsForKey","getAllDataForKey","querys","storage","storageBackend","window","localStorage","getCacheTokens","cacheToken","cacheRefreshToken","cacheSession","cookieName","clearCacheTokens","setCacheTokens","g"],"mappings":"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","sourcesContent":["/**\n * Ported from https://github.com/sunnylqm/react-native-storage\n * Credit: Sunny Luo /sunnylqm\n */\n\n/**\n * Created by sunny on 9/1/16.\n */\n\nexport class NotFoundError extends Error {\n    constructor(message) {\n        super(`Not Found! Params: ${message}`);\n        this.name = 'NotFoundError';\n        this.stack = new Error().stack; // Optional\n    }\n}\n// NotFoundError.prototype = Object.create(Error.prototype);\n\nexport class ExpiredError extends Error {\n    constructor(message) {\n        super(`Expired! Params: ${message}`);\n        this.name = 'ExpiredError';\n        this.stack = new Error().stack; // Optional\n    }\n}\n","/* eslint-disable */\n\n/**\n * Ported from https://github.com/sunnylqm/react-native-storage\n * Credit: Sunny Luo /sunnylqm\n */\n\n/*\n *  local storage(web/react native) wrapper\n *  sunnylqm\n */\nimport { NotFoundError, ExpiredError } from './error';\n\nexport { NotFoundError, ExpiredError };\n\nexport default class Storage {\n    constructor(options = {}) {\n        this._SIZE = options.size || 1000; // maximum key-ids capacity\n        this.sync = options.sync || {}; // remote sync method\n        this.defaultExpires = options.defaultExpires !== undefined ? options.defaultExpires : 1000 * 3600 * 24;\n        this.enableCache = options.enableCache !== false;\n        this._s = options.storageBackend || null;\n        this._innerVersion = 11;\n        this.cache = {};\n\n        if (this._s && this._s.setItem) {\n            try {\n                var promiseTest = this._s.setItem('__react_native_storage_test', 'test');\n                this.isPromise = !!(promiseTest && promiseTest.then);\n            } catch (e) {\n                console.warn(e);\n                delete this._s;\n                throw e;\n            }\n        } else {\n            console.warn(`Data would be lost after reload cause there is no storageBackend specified!\n      \\nEither use localStorage(for web) or AsyncStorage(for React Native) as a storageBackend.`);\n        }\n\n        this._mapPromise = this.getItem('map').then(map => {\n            this._m = this._checkMap((map && JSON.parse(map)) || {});\n        });\n    }\n    getItem(key) {\n        return this._s\n            ? this.isPromise\n                ? this._s.getItem(key)\n                : Promise.resolve(this._s.getItem(key))\n            : Promise.resolve();\n    }\n    setItem(key, value) {\n        return this._s\n            ? this.isPromise\n                ? this._s.setItem(key, value)\n                : Promise.resolve(this._s.setItem(key, value))\n            : Promise.resolve();\n    }\n    removeItem(key) {\n        return this._s\n            ? this.isPromise\n                ? this._s.removeItem(key)\n                : Promise.resolve(this._s.removeItem(key))\n            : Promise.resolve();\n    }\n    _initMap() {\n        return {\n            innerVersion: this._innerVersion,\n            index: 0,\n            __keys__: {},\n        };\n    }\n    _checkMap(map) {\n        if (map && map.innerVersion && map.innerVersion === this._innerVersion) {\n            return map;\n        } else {\n            return this._initMap();\n        }\n    }\n    _getId(key, id) {\n        return key + '_' + id;\n    }\n    _saveToMap(params) {\n        let { key, id, data } = params,\n            newId = this._getId(key, id),\n            m = this._m;\n        if (m[newId] !== undefined) {\n            // update existing data\n            if (this.enableCache) this.cache[newId] = JSON.parse(data);\n            return this.setItem('map_' + m[newId], data);\n        }\n        if (m[m.index] !== undefined) {\n            // loop over, delete old data\n            let oldId = m[m.index];\n            let splitOldId = oldId.split('_');\n            delete m[oldId];\n            this._removeIdInKey(splitOldId[0], splitOldId[1]);\n            if (this.enableCache) {\n                delete this.cache[oldId];\n            }\n        }\n        m[newId] = m.index;\n        m[m.index] = newId;\n\n        m.__keys__[key] = m.__keys__[key] || [];\n        m.__keys__[key].push(id);\n\n        if (this.enableCache) {\n            const cacheData = JSON.parse(data);\n            this.cache[newId] = cacheData;\n        }\n        let currentIndex = m.index;\n        if (++m.index === this._SIZE) {\n            m.index = 0;\n        }\n        this.setItem('map_' + currentIndex, data);\n        this.setItem('map', JSON.stringify(m));\n    }\n    save(params) {\n        const { key, id, data, rawData, expires = this.defaultExpires } = params;\n        if (key.toString().indexOf('_') !== -1) {\n            console.error('Please do not use \"_\" in key!');\n        }\n        let dataToSave = { rawData: data };\n        if (data === undefined) {\n            if (rawData !== undefined) {\n                console.warn('\"rawData\" is deprecated, please use \"data\" instead!');\n                dataToSave.rawData = rawData;\n            } else {\n                console.error('\"data\" is required in save()!');\n                return;\n            }\n        }\n        let now = Date.now();\n        if (expires !== null) {\n            dataToSave.expires = now + expires;\n        }\n        dataToSave = JSON.stringify(dataToSave);\n        if (id === undefined) {\n            if (this.enableCache) {\n                const cacheData = JSON.parse(dataToSave);\n                this.cache[key] = cacheData;\n            }\n            return this.setItem(key, dataToSave);\n        } else {\n            if (id.toString().indexOf('_') !== -1) {\n                console.error('Please do not use \"_\" in id!');\n            }\n            return this._mapPromise.then(() =>\n                this._saveToMap({\n                    key,\n                    id,\n                    data: dataToSave,\n                }),\n            );\n        }\n    }\n    getBatchData(querys) {\n        return Promise.all(querys.map(query => this.load(query)));\n    }\n    async getBatchDataWithIds(params) {\n        let { key, ids, syncInBackground, syncParams } = params;\n        const tasks = ids.map(id =>\n            this.load({\n                key,\n                id,\n                syncInBackground,\n                autoSync: false,\n                batched: true,\n            }),\n        );\n        const results = await Promise.all(tasks);\n        const missingIds = [];\n        results.forEach(value => {\n            if (value.syncId !== undefined) {\n                missingIds.push(value.syncId);\n            }\n        });\n        if (missingIds.length) {\n            const syncData = await this.sync[key]({\n                id: missingIds,\n                syncParams,\n            });\n            return results.map(value => {\n                return value.syncId ? syncData.shift() : value;\n            });\n        } else {\n            return results;\n        }\n    }\n    _lookupGlobalItem(params) {\n        const { key } = params;\n        if (this.enableCache && this.cache[key] !== undefined) {\n            return this._loadGlobalItem({ ret: this.cache[key], ...params });\n        }\n        return this.getItem(key).then(ret => this._loadGlobalItem({ ret, ...params }));\n    }\n    _loadGlobalItem(params) {\n        let { key, ret, autoSync, syncInBackground, syncParams } = params;\n        if (ret === null || ret === undefined) {\n            if (autoSync && this.sync[key]) {\n                return this.sync[key]({ syncParams });\n            }\n            throw new NotFoundError(JSON.stringify(params));\n        }\n        if (typeof ret === 'string') {\n            ret = JSON.parse(ret);\n            if (this.enableCache) {\n                this.cache[key] = ret;\n            }\n        }\n        let now = Date.now();\n        if (ret.expires < now) {\n            if (autoSync && this.sync[key]) {\n                if (syncInBackground) {\n                    try {\n                        this.sync[key]({ syncParams, syncInBackground });\n                    } catch (e) {\n                        // avoid uncaught exception\n                    }\n                    return ret.rawData;\n                }\n                return this.sync[key]({ syncParams, syncInBackground });\n            }\n            throw new ExpiredError(JSON.stringify(params));\n        }\n        return ret.rawData;\n    }\n    _noItemFound(params) {\n        let { key, id, autoSync, syncParams } = params;\n        if (this.sync[key]) {\n            if (autoSync) {\n                return this.sync[key]({ id, syncParams });\n            }\n            return { syncId: id };\n        }\n        throw new NotFoundError(JSON.stringify(params));\n    }\n    _loadMapItem(params) {\n        let { ret, key, id, autoSync, batched, syncInBackground, syncParams } = params;\n        if (ret === null || ret === undefined) {\n            return this._noItemFound(params);\n        }\n        if (typeof ret === 'string') {\n            ret = JSON.parse(ret);\n            const { key, id } = params;\n            const newId = this._getId(key, id);\n            if (this.enableCache) {\n                this.cache[newId] = ret;\n            }\n        }\n        let now = Date.now();\n        if (ret.expires < now) {\n            if (autoSync && this.sync[key]) {\n                if (syncInBackground) {\n                    try {\n                        this.sync[key]({ id, syncParams, syncInBackground });\n                    } catch (e) {\n                        // avoid uncaught exception\n                    }\n                    return ret.rawData;\n                }\n                return this.sync[key]({ id, syncParams, syncInBackground });\n            }\n            if (batched) {\n                return { syncId: id };\n            }\n            throw new ExpiredError(JSON.stringify(params));\n        }\n        return ret.rawData;\n    }\n    _lookUpInMap(params) {\n        let ret;\n        const m = this._m;\n        const { key, id } = params;\n        const newId = this._getId(key, id);\n        if (this.enableCache && this.cache[newId]) {\n            ret = this.cache[newId];\n            return this._loadMapItem({ ret, ...params });\n        }\n        if (m[newId] !== undefined) {\n            return this.getItem('map_' + m[newId]).then(ret => this._loadMapItem({ ret, ...params }));\n        }\n        return this._noItemFound({ ret, ...params });\n    }\n    remove(params) {\n        return this._mapPromise.then(() => {\n            let m = this._m;\n            let { key, id } = params;\n\n            if (id === undefined) {\n                if (this.enableCache && this.cache[key]) {\n                    delete this.cache[key];\n                }\n                return this.removeItem(key);\n            }\n            let newId = this._getId(key, id);\n\n            // remove existing data\n            if (m[newId] !== undefined) {\n                if (this.enableCache && this.cache[newId]) {\n                    delete this.cache[newId];\n                }\n                this._removeIdInKey(key, id);\n                let idTobeDeleted = m[newId];\n                delete m[newId];\n                this.setItem('map', JSON.stringify(m));\n                return this.removeItem('map_' + idTobeDeleted);\n            }\n        });\n    }\n    _removeIdInKey(key, id) {\n        const indexTobeRemoved = (this._m.__keys__[key] || []).indexOf(id);\n        if (indexTobeRemoved !== -1) {\n            this._m.__keys__[key].splice(indexTobeRemoved, 1);\n        }\n    }\n    load(params) {\n        const { key, id, autoSync = true, syncInBackground = true, syncParams, batched } = params;\n        return this._mapPromise.then(() => {\n            if (id === undefined) {\n                return this._lookupGlobalItem({\n                    key,\n                    autoSync,\n                    syncInBackground,\n                    syncParams,\n                });\n            } else {\n                return this._lookUpInMap({\n                    key,\n                    id,\n                    autoSync,\n                    syncInBackground,\n                    batched,\n                    syncParams,\n                });\n            }\n        });\n    }\n    clearAll() {\n        this._s.clear && this._s.clear();\n        this._m = this._initMap();\n    }\n    clearMap() {\n        return this.removeItem('map').then(() => {\n            this.cache = {};\n            this._m = this._initMap();\n        });\n    }\n    clearMapForKey(key) {\n        return this._mapPromise.then(() => {\n            let tasks = (this._m.__keys__[key] || []).map(id => this.remove({ key, id }));\n            return Promise.all(tasks);\n        });\n    }\n    getIdsForKey(key) {\n        return this._mapPromise.then(() => {\n            return this._m.__keys__[key] || [];\n        });\n    }\n    getAllDataForKey(key, options) {\n        options = Object.assign({ syncInBackground: true }, options);\n        return this.getIdsForKey(key).then(ids => {\n            const querys = ids.map(id => ({ key, id, syncInBackground: options.syncInBackground }));\n            return this.getBatchData(querys);\n        });\n    }\n}\n","import Storage from './storage';\n\nconst storage = new Storage({ storageBackend: window.localStorage });\n\n// https://github.com/sunnylqm/react-native-storage\nexport async function getCacheTokens(cookieName: string): Promise<Record<string, any>> {\n    let cacheToken = false;\n    let cacheRefreshToken = false;\n    let cacheSession = false;\n\n    try {\n        cacheToken = await storage.load({ key: cookieName + \"token\" });\n    } catch (_) {}\n\n    try {\n        cacheRefreshToken = await storage.load({ key: cookieName + \"refreshToken\" });\n    } catch (_) {}\n\n    try {\n        cacheSession = await storage.load({ key: cookieName + \"session\" });\n    } catch (_) {}\n\n    return {\n        cacheToken,\n        cacheRefreshToken,\n        cacheSession\n    }\n}\n\nexport async function clearCacheTokens(cookieName: string) {\n    await storage.remove({ key: cookieName + \"token\" });\n    await storage.remove({ key: cookieName + \"refreshToken\" });\n    await storage.remove({ key: cookieName + \"session\" });\n}\n\nexport async function setCacheTokens(g: any, cookieName: string) {\n    await storage.save({\n        key: cookieName + \"token\",\n        data: g.token,\n        expires: 3600 * 1000 * 24\n    });\n\n    await storage.save({\n        key: cookieName + \"refreshToken\",\n        data: g.refreshToken,\n        expires: 3600 * 1000 * 24\n    });\n\n    await storage.save({\n        key: cookieName + \"session\",\n        data: g.session,\n        expires: null\n    });\n}\n"]},"metadata":{},"sourceType":"script"}