{"ast":null,"code":"import { _ as _extends } from './index-9b07a9d3.js';\nimport * as React from 'react';\nimport React__default from 'react';\nimport { q as qe } from './Auth-016a6bca.js';\nconst Form = qe.form(props => _extends({\n  display: \"flex\",\n  justifyContent: \"center\",\n  minWidth: 300,\n  width: 380,\n  padding: '33px 55px',\n  boxShadow: '0 5px 10px 0 rgb(0 0 0 / 10%)',\n  borderRadius: 10,\n  flexDirection: 'column',\n  fontFamily: \"inherit\",\n  margin: '6% auto 50px',\n  '@media (max-width: 520px)': {\n    margin: '0px !important',\n    position: 'fixed !important',\n    top: 0,\n    left: 0,\n    right: 0,\n    bottom: 0,\n    width: 'initial !important'\n  }\n}, props.theme.form ? _extends({}, props.theme.form) : {}));\n\nfunction Form$1(props) {\n  return React__default.createElement(Form, Object.assign({}, props), props.children);\n}\n\nconst Label = qe.label(props => _extends({\n  display: \"none\",\n  fontFamily: \"inherit\"\n}, props.theme.textFieldLabel ? _extends({}, props.theme.textFieldLabel) : {}));\n\nfunction Label$1(props) {\n  return React__default.createElement(Label, Object.assign({}, props));\n}\n\nconst TextFieldRoot = qe.div(props => _extends({\n  position: 'relative',\n  width: '100%',\n  maxWidth: '100%',\n  padding: 0,\n  height: 46,\n  fontFamily: \"inherit\"\n}, props.theme.textFieldRoot ? _extends({}, props.theme.textFieldRoot) : {}));\nconst TextField = qe.input(props => _extends({\n  display: \"block\",\n  width: '100%',\n  background: '0 0',\n  border: 'none',\n  fontFamily: \"inherit\"\n}, props.theme.textField ? _extends({}, props.theme.textField) : {}));\nconst Bar = qe.div(props => props.theme.textFieldBar ? _extends({}, props.theme.textFieldBar) : {});\n\nfunction Input(props) {\n  return React__default.createElement(TextFieldRoot, null, React__default.createElement(TextField, Object.assign({\n    placeholder: \"\\u00A0\"\n  }, props, props.register(), {\n    id: \"textField-\" + props.label.replace(/[^a-zA-Z]+/g, '')\n  })), React__default.createElement(Bar, null), React__default.createElement(Label$1, {\n    htmlFor: \"textField-\" + props.label.replace(/[^a-zA-Z]+/g, '')\n  }, props.label));\n}\n\nfunction EmailInput(props) {\n  return React__default.createElement(Input, Object.assign({\n    label: \"Email\",\n    autoComplete: \"email\"\n  }, props, {\n    type: \"email\",\n    required: true\n  }));\n}\n\nfunction PasswordInput(props) {\n  return React__default.createElement(Input, Object.assign({\n    label: \"Password\"\n  }, props, {\n    type: \"password\",\n    required: true\n  }));\n}\n\nconst HeaderText = qe.h1(props => _extends({\n  fontFamily: \"inherit\",\n  fontSize: 24,\n  fontWeight: 500,\n  letterSpacing: -.2,\n  marginBlockStart: '0.67em',\n  marginBlockEnd: '0.67em',\n  marginInlineStart: 0,\n  marginInlineEnd: 0,\n  marginTop: '16px !important'\n}, props.theme.headerText ? _extends({}, props.theme.headerText) : {}));\n\nfunction HeaderText$1(props) {\n  return React__default.createElement(HeaderText, Object.assign({}, props));\n}\n\nconst TextButton = qe.button(props => _extends({\n  cursor: \"pointer\",\n  color: '#635bff',\n  whiteSpace: 'nowrap',\n  fontWeight: 500,\n  fontSize: 14,\n  margin: 0,\n  background: 'none',\n  border: 'none'\n}, props.theme.textButton ? _extends({}, props.theme.textButton) : {}));\n\nfunction TextButton$1(props) {\n  return React__default.createElement(TextButton, Object.assign({}, props, {\n    type: \"button\"\n  }));\n}\n\nconst SecondaryButton = qe(TextButton$1)(props => _extends({\n  margin: '15px'\n}, props.theme.secondaryButton ? _extends({}, props.theme.secondaryButton) : {}));\n\nfunction SecondaryButton$1(props) {\n  return React__default.createElement(SecondaryButton, Object.assign({}, props));\n}\n\nconst SubmitButtonRoot = qe.div(props => props.theme.submitButtonRoot ? props.theme.submitButtonRoot : {});\nconst SubmitButton = qe.button(props => _extends({\n  position: 'relative',\n  border: \"none\",\n  verticalAlign: \"middle\",\n  textAlign: \"center\",\n  textOverflow: \"ellipsis\",\n  overflow: \"hidden\",\n  outline: \"none\",\n  cursor: \"pointer\",\n  boxSizing: 'border-box'\n}, props.theme.submitButton ? _extends({}, props.theme.submitButton) : {}));\n\nfunction SubmitButton$1(props) {\n  return React__default.createElement(SubmitButtonRoot, null, React__default.createElement(SubmitButton, Object.assign({\n    type: \"submit\"\n  }, props)));\n}\n\nfunction Spacer(props) {\n  switch (props.size) {\n    case \"xlarge\":\n      return React__default.createElement(\"div\", {\n        style: {\n          height: 64\n        }\n      });\n\n    case \"large\":\n      return React__default.createElement(\"div\", {\n        style: {\n          height: 58\n        }\n      });\n\n    case \"small\":\n      return React__default.createElement(\"div\", {\n        style: {\n          height: 16\n        }\n      });\n\n    default:\n      return React__default.createElement(\"div\", {\n        style: {\n          height: 37\n        }\n      });\n  }\n}\n\nvar isCheckBoxInput = element => element.type === 'checkbox';\n\nvar isNullOrUndefined = value => value == null;\n\nconst isObjectType = value => typeof value === 'object';\n\nvar isObject = value => !isNullOrUndefined(value) && !Array.isArray(value) && isObjectType(value) && !(value instanceof Date);\n\nvar getNodeParentName = name => name.substring(0, name.search(/.\\d/)) || name;\n\nvar isNameInFieldArray = (names, name) => [...names].some(current => getNodeParentName(name) === current);\n\nvar compact = value => value.filter(Boolean);\n\nvar isUndefined = val => val === undefined;\n\nvar get = (obj, path, defaultValue) => {\n  if (isObject(obj) && path) {\n    const result = compact(path.split(/[,[\\].]+?/)).reduce((result, key) => isNullOrUndefined(result) ? result : result[key], obj);\n    return isUndefined(result) || result === obj ? isUndefined(obj[path]) ? defaultValue : obj[path] : result;\n  }\n\n  return undefined;\n};\n\nconst EVENTS = {\n  BLUR: 'blur',\n  CHANGE: 'change'\n};\nconst VALIDATION_MODE = {\n  onBlur: 'onBlur',\n  onChange: 'onChange',\n  onSubmit: 'onSubmit',\n  onTouched: 'onTouched',\n  all: 'all'\n};\nconst INPUT_VALIDATION_RULES = {\n  max: 'max',\n  min: 'min',\n  maxLength: 'maxLength',\n  minLength: 'minLength',\n  pattern: 'pattern',\n  required: 'required',\n  validate: 'validate'\n};\n\nvar omit = (source, key) => {\n  const copy = Object.assign({}, source);\n  delete copy[key];\n  return copy;\n};\n\nconst FormContext = React.createContext(null);\nFormContext.displayName = 'RHFContext';\n\nvar getProxyFormState = (isProxyEnabled, formState, readFormStateRef, localReadFormStateRef, isRoot = true) => isProxyEnabled ? new Proxy(formState, {\n  get: (obj, prop) => {\n    if (prop in obj) {\n      if (readFormStateRef.current[prop] !== VALIDATION_MODE.all) {\n        readFormStateRef.current[prop] = isRoot ? VALIDATION_MODE.all : true;\n      }\n\n      localReadFormStateRef && (localReadFormStateRef.current[prop] = true);\n      return obj[prop];\n    }\n\n    return undefined;\n  }\n}) : formState;\n\nvar isEmptyObject = value => isObject(value) && !Object.keys(value).length;\n\nvar shouldRenderFormState = (formStateData, readFormStateRef, isRoot) => {\n  const formState = omit(formStateData, 'name');\n  return isEmptyObject(formState) || Object.keys(formState).length >= Object.keys(readFormStateRef).length || Object.keys(formState).find(key => readFormStateRef[key] === (isRoot ? VALIDATION_MODE.all : true));\n};\n\nvar convertToArrayPayload = value => Array.isArray(value) ? value : [value];\n\nvar isWeb = typeof window !== 'undefined' && typeof window.HTMLElement !== 'undefined' && typeof document !== 'undefined';\nconst isProxyEnabled = isWeb ? 'Proxy' in window : typeof Proxy !== 'undefined';\n\nvar appendErrors = (name, validateAllFieldCriteria, errors, type, message) => validateAllFieldCriteria ? Object.assign(Object.assign({}, errors[name]), {\n  types: Object.assign(Object.assign({}, errors[name] && errors[name].types ? errors[name].types : {}), {\n    [type]: message || true\n  })\n}) : {};\n\nvar isKey = value => /^\\w*$/.test(value);\n\nvar stringToPath = input => compact(input.replace(/[\"|']|\\]/g, '').split(/\\.|\\[/));\n\nfunction set(object, path, value) {\n  let index = -1;\n  const tempPath = isKey(path) ? [path] : stringToPath(path);\n  const length = tempPath.length;\n  const lastIndex = length - 1;\n\n  while (++index < length) {\n    const key = tempPath[index];\n    let newValue = value;\n\n    if (index !== lastIndex) {\n      const objValue = object[key];\n      newValue = isObject(objValue) || Array.isArray(objValue) ? objValue : !isNaN(+tempPath[index + 1]) ? [] : {};\n    }\n\n    object[key] = newValue;\n    object = object[key];\n  }\n\n  return object;\n}\n\nconst focusFieldBy = (fields, callback, fieldsNames) => {\n  for (const key of fieldsNames || Object.keys(fields)) {\n    const field = get(fields, key);\n\n    if (field) {\n      const _f = field._f;\n      const current = omit(field, '_f');\n\n      if (_f && callback(_f.name)) {\n        if (_f.ref.focus && isUndefined(_f.ref.focus())) {\n          break;\n        } else if (_f.refs) {\n          _f.refs[0].focus();\n\n          break;\n        }\n      } else if (isObject(current)) {\n        focusFieldBy(current, callback);\n      }\n    }\n  }\n};\n\nconst getFieldsValues = (fieldsRef, output = {}) => {\n  for (const name in fieldsRef.current) {\n    const field = fieldsRef.current[name];\n\n    if (field && !isNullOrUndefined(output)) {\n      const _f = field._f;\n      const current = omit(field, '_f');\n      set(output, name, _f && _f.ref ? _f.ref.disabled || _f.refs && _f.refs.every(ref => ref.disabled) ? undefined : _f.value : Array.isArray(field) ? [] : {});\n      current && getFieldsValues({\n        current\n      }, output[name]);\n    }\n  }\n\n  return output;\n};\n\nvar isPrimitive = value => isNullOrUndefined(value) || !isObjectType(value);\n\nfunction deepEqual(object1, object2, isErrorObject) {\n  if (isPrimitive(object1) || isPrimitive(object2) || object1 instanceof Date || object2 instanceof Date) {\n    return object1 === object2;\n  }\n\n  if (!React.isValidElement(object1)) {\n    const keys1 = Object.keys(object1);\n    const keys2 = Object.keys(object2);\n\n    if (keys1.length !== keys2.length) {\n      return false;\n    }\n\n    for (const key of keys1) {\n      const val1 = object1[key];\n\n      if (!(isErrorObject && key === 'ref')) {\n        const val2 = object2[key];\n\n        if ((isObject(val1) || Array.isArray(val1)) && (isObject(val2) || Array.isArray(val2)) ? !deepEqual(val1, val2, isErrorObject) : val1 !== val2) {\n          return false;\n        }\n      }\n    }\n  }\n\n  return true;\n}\n\nfunction deepMerge(target, source) {\n  if (isPrimitive(target) || isPrimitive(source)) {\n    return source;\n  }\n\n  for (const key in source) {\n    const targetValue = target[key];\n    const sourceValue = source[key];\n\n    try {\n      target[key] = isObject(targetValue) && isObject(sourceValue) || Array.isArray(targetValue) && Array.isArray(sourceValue) ? deepMerge(targetValue, sourceValue) : sourceValue;\n    } catch (_a) {}\n  }\n\n  return target;\n}\n\nfunction setDirtyFields(values, defaultValues, dirtyFields, parentNode, parentName) {\n  let index = -1;\n\n  while (++index < values.length) {\n    for (const key in values[index]) {\n      if (Array.isArray(values[index][key])) {\n        !dirtyFields[index] && (dirtyFields[index] = {});\n        dirtyFields[index][key] = [];\n        setDirtyFields(values[index][key], get(defaultValues[index] || {}, key, []), dirtyFields[index][key], dirtyFields[index], key);\n      } else {\n        deepEqual(get(defaultValues[index] || {}, key), values[index][key]) ? set(dirtyFields[index] || {}, key) : dirtyFields[index] = Object.assign(Object.assign({}, dirtyFields[index]), {\n          [key]: true\n        });\n      }\n    }\n\n    parentNode && !dirtyFields.length && delete parentNode[parentName];\n  }\n\n  return dirtyFields;\n}\n\nvar setFieldArrayDirtyFields = (values, defaultValues, dirtyFields) => deepMerge(setDirtyFields(values, defaultValues, dirtyFields.slice(0, values.length)), setDirtyFields(defaultValues, values, dirtyFields.slice(0, values.length)));\n\nvar isString = value => typeof value === 'string';\n\nvar isBoolean = value => typeof value === 'boolean';\n\nfunction baseGet(object, updatePath) {\n  const length = updatePath.slice(0, -1).length;\n  let index = 0;\n\n  while (index < length) {\n    object = isUndefined(object) ? index++ : object[updatePath[index++]];\n  }\n\n  return object;\n}\n\nfunction unset(object, path) {\n  const updatePath = isKey(path) ? [path] : stringToPath(path);\n  const childObject = updatePath.length == 1 ? object : baseGet(object, updatePath);\n  const key = updatePath[updatePath.length - 1];\n  let previousObjRef;\n\n  if (childObject) {\n    delete childObject[key];\n  }\n\n  for (let k = 0; k < updatePath.slice(0, -1).length; k++) {\n    let index = -1;\n    let objectRef;\n    const currentPaths = updatePath.slice(0, -(k + 1));\n    const currentPathsLength = currentPaths.length - 1;\n\n    if (k > 0) {\n      previousObjRef = object;\n    }\n\n    while (++index < currentPaths.length) {\n      const item = currentPaths[index];\n      objectRef = objectRef ? objectRef[item] : object[item];\n\n      if (currentPathsLength === index && (isObject(objectRef) && isEmptyObject(objectRef) || Array.isArray(objectRef) && !objectRef.filter(data => isObject(data) && !isEmptyObject(data) || isBoolean(data)).length)) {\n        previousObjRef ? delete previousObjRef[item] : delete object[item];\n      }\n\n      previousObjRef = objectRef;\n    }\n  }\n\n  return object;\n}\n\nfunction getFields(fieldsNames, fieldsRefs) {\n  const currentFields = {};\n\n  for (const name of fieldsNames) {\n    const field = get(fieldsRefs, name);\n\n    if (field) {\n      !isKey(name) ? set(currentFields, name, field._f) : currentFields[name] = field._f;\n    }\n  }\n\n  return currentFields;\n}\n\nvar isFileInput = element => element.type === 'file';\n\nvar isMultipleSelect = element => element.type === `select-multiple`;\n\nvar isRadioInput = element => element.type === 'radio';\n\nconst defaultResult = {\n  value: false,\n  isValid: false\n};\nconst validResult = {\n  value: true,\n  isValid: true\n};\n\nvar getCheckboxValue = options => {\n  if (Array.isArray(options)) {\n    if (options.length > 1) {\n      const values = options.filter(option => option && option.checked && !option.disabled).map(option => option.value);\n      return {\n        value: values,\n        isValid: !!values.length\n      };\n    }\n\n    return options[0].checked && !options[0].disabled ? // @ts-expect-error expected to work in the browser\n    options[0].attributes && !isUndefined(options[0].attributes.value) ? isUndefined(options[0].value) || options[0].value === '' ? validResult : {\n      value: options[0].value,\n      isValid: true\n    } : validResult : defaultResult;\n  }\n\n  return defaultResult;\n};\n\nvar getFieldValueAs = (value, {\n  valueAsNumber,\n  valueAsDate,\n  setValueAs\n}) => isUndefined(value) ? value : valueAsNumber ? value === '' ? NaN : +value : valueAsDate ? new Date(value) : setValueAs ? setValueAs(value) : value;\n\nvar getMultipleSelectValue = options => [...options].filter(({\n  selected\n}) => selected).map(({\n  value\n}) => value);\n\nconst defaultReturn = {\n  isValid: false,\n  value: null\n};\n\nvar getRadioValue = options => Array.isArray(options) ? options.reduce((previous, option) => option && option.checked && !option.disabled ? {\n  isValid: true,\n  value: option.value\n} : previous, defaultReturn) : defaultReturn;\n\nfunction getFieldValue(field) {\n  if (field && field._f) {\n    const ref = field._f.ref;\n\n    if (ref.disabled) {\n      return;\n    }\n\n    if (isFileInput(ref)) {\n      return ref.files;\n    }\n\n    if (isRadioInput(ref)) {\n      return getRadioValue(field._f.refs).value;\n    }\n\n    if (isMultipleSelect(ref)) {\n      return getMultipleSelectValue(ref.options);\n    }\n\n    if (isCheckBoxInput(ref)) {\n      return getCheckboxValue(field._f.refs).value;\n    }\n\n    return getFieldValueAs(isUndefined(ref.value) ? field._f.ref.value : ref.value, field._f);\n  }\n}\n\nvar hasValidation = (options, mounted) => mounted && options && (options.required || options.min || options.max || options.maxLength || options.minLength || options.pattern || options.validate);\n\nvar skipValidation = ({\n  isOnBlur,\n  isOnChange,\n  isOnTouch,\n  isTouched,\n  isReValidateOnBlur,\n  isReValidateOnChange,\n  isBlurEvent,\n  isSubmitted,\n  isOnAll\n}) => {\n  if (isOnAll) {\n    return false;\n  } else if (!isSubmitted && isOnTouch) {\n    return !(isTouched || isBlurEvent);\n  } else if (isSubmitted ? isReValidateOnBlur : isOnBlur) {\n    return !isBlurEvent;\n  } else if (isSubmitted ? isReValidateOnChange : isOnChange) {\n    return isBlurEvent;\n  }\n\n  return true;\n};\n\nvar isFunction = value => typeof value === 'function';\n\nvar isMessage = value => isString(value) || React.isValidElement(value);\n\nvar isRegex = value => value instanceof RegExp;\n\nfunction getValidateError(result, ref, type = 'validate') {\n  if (isMessage(result) || Array.isArray(result) && result.every(isMessage) || isBoolean(result) && !result) {\n    return {\n      type,\n      message: isMessage(result) ? result : '',\n      ref\n    };\n  }\n}\n\nvar getValueAndMessage = validationData => isObject(validationData) && !isRegex(validationData) ? validationData : {\n  value: validationData,\n  message: ''\n};\n\nvar validateField = async ({\n  _f: {\n    ref,\n    refs,\n    required,\n    maxLength,\n    minLength,\n    min,\n    max,\n    pattern,\n    validate,\n    name,\n    value: inputValue,\n    valueAsNumber,\n    mount\n  }\n}, validateAllFieldCriteria) => {\n  if (!mount) {\n    return {};\n  }\n\n  const error = {};\n  const isRadio = isRadioInput(ref);\n  const isCheckBox = isCheckBoxInput(ref);\n  const isRadioOrCheckbox = isRadio || isCheckBox;\n  const isEmpty = (valueAsNumber || isFileInput(ref)) && !ref.value || inputValue === '' || Array.isArray(inputValue) && !inputValue.length;\n  const appendErrorsCurry = appendErrors.bind(null, name, validateAllFieldCriteria, error);\n\n  const getMinMaxMessage = (exceedMax, maxLengthMessage, minLengthMessage, maxType = INPUT_VALIDATION_RULES.maxLength, minType = INPUT_VALIDATION_RULES.minLength) => {\n    const message = exceedMax ? maxLengthMessage : minLengthMessage;\n    error[name] = Object.assign({\n      type: exceedMax ? maxType : minType,\n      message,\n      ref\n    }, appendErrorsCurry(exceedMax ? maxType : minType, message));\n  };\n\n  if (required && (!isRadio && !isCheckBox && (isEmpty || isNullOrUndefined(inputValue)) || isBoolean(inputValue) && !inputValue || isCheckBox && !getCheckboxValue(refs).isValid || isRadio && !getRadioValue(refs).isValid)) {\n    const {\n      value,\n      message\n    } = isMessage(required) ? {\n      value: !!required,\n      message: required\n    } : getValueAndMessage(required);\n\n    if (value) {\n      error[name] = Object.assign({\n        type: INPUT_VALIDATION_RULES.required,\n        message,\n        ref: isRadioOrCheckbox ? (refs || [])[0] || {} : ref\n      }, appendErrorsCurry(INPUT_VALIDATION_RULES.required, message));\n\n      if (!validateAllFieldCriteria) {\n        return error;\n      }\n    }\n  }\n\n  if ((!isNullOrUndefined(min) || !isNullOrUndefined(max)) && inputValue !== '') {\n    let exceedMax;\n    let exceedMin;\n    const maxOutput = getValueAndMessage(max);\n    const minOutput = getValueAndMessage(min);\n\n    if (!isNaN(inputValue)) {\n      const valueNumber = ref.valueAsNumber || parseFloat(inputValue);\n\n      if (!isNullOrUndefined(maxOutput.value)) {\n        exceedMax = valueNumber > maxOutput.value;\n      }\n\n      if (!isNullOrUndefined(minOutput.value)) {\n        exceedMin = valueNumber < minOutput.value;\n      }\n    } else {\n      const valueDate = ref.valueAsDate || new Date(inputValue);\n\n      if (isString(maxOutput.value)) {\n        exceedMax = valueDate > new Date(maxOutput.value);\n      }\n\n      if (isString(minOutput.value)) {\n        exceedMin = valueDate < new Date(minOutput.value);\n      }\n    }\n\n    if (exceedMax || exceedMin) {\n      getMinMaxMessage(!!exceedMax, maxOutput.message, minOutput.message, INPUT_VALIDATION_RULES.max, INPUT_VALIDATION_RULES.min);\n\n      if (!validateAllFieldCriteria) {\n        return error;\n      }\n    }\n  }\n\n  if (isString(inputValue) && !isEmpty && (maxLength || minLength)) {\n    const maxLengthOutput = getValueAndMessage(maxLength);\n    const minLengthOutput = getValueAndMessage(minLength);\n    const exceedMax = !isNullOrUndefined(maxLengthOutput.value) && inputValue.length > maxLengthOutput.value;\n    const exceedMin = !isNullOrUndefined(minLengthOutput.value) && inputValue.length < minLengthOutput.value;\n\n    if (exceedMax || exceedMin) {\n      getMinMaxMessage(exceedMax, maxLengthOutput.message, minLengthOutput.message);\n\n      if (!validateAllFieldCriteria) {\n        return error;\n      }\n    }\n  }\n\n  if (isString(inputValue) && pattern && !isEmpty) {\n    const {\n      value: patternValue,\n      message\n    } = getValueAndMessage(pattern);\n\n    if (isRegex(patternValue) && !inputValue.match(patternValue)) {\n      error[name] = Object.assign({\n        type: INPUT_VALIDATION_RULES.pattern,\n        message,\n        ref\n      }, appendErrorsCurry(INPUT_VALIDATION_RULES.pattern, message));\n\n      if (!validateAllFieldCriteria) {\n        return error;\n      }\n    }\n  }\n\n  if (validate) {\n    const validateRef = isRadioOrCheckbox && refs ? refs[0] : ref;\n\n    if (isFunction(validate)) {\n      const result = await validate(inputValue);\n      const validateError = getValidateError(result, validateRef);\n\n      if (validateError) {\n        error[name] = Object.assign(Object.assign({}, validateError), appendErrorsCurry(INPUT_VALIDATION_RULES.validate, validateError.message));\n\n        if (!validateAllFieldCriteria) {\n          return error;\n        }\n      }\n    } else if (isObject(validate)) {\n      let validationResult = {};\n\n      for (const [key, validateFunction] of Object.entries(validate)) {\n        if (!isEmptyObject(validationResult) && !validateAllFieldCriteria) {\n          break;\n        }\n\n        const validateResult = await validateFunction(inputValue);\n        const validateError = getValidateError(validateResult, validateRef, key);\n\n        if (validateError) {\n          validationResult = Object.assign(Object.assign({}, validateError), appendErrorsCurry(key, validateError.message));\n\n          if (validateAllFieldCriteria) {\n            error[name] = validationResult;\n          }\n        }\n      }\n\n      if (!isEmptyObject(validationResult)) {\n        error[name] = Object.assign({\n          ref: validateRef\n        }, validationResult);\n\n        if (!validateAllFieldCriteria) {\n          return error;\n        }\n      }\n    }\n  }\n\n  return error;\n};\n\nvar getValidationModes = mode => ({\n  isOnSubmit: !mode || mode === VALIDATION_MODE.onSubmit,\n  isOnBlur: mode === VALIDATION_MODE.onBlur,\n  isOnChange: mode === VALIDATION_MODE.onChange,\n  isOnAll: mode === VALIDATION_MODE.all,\n  isOnTouch: mode === VALIDATION_MODE.onTouched\n});\n\nvar isHTMLElement = value => value instanceof HTMLElement;\n\nvar isRadioOrCheckboxFunction = ref => isRadioInput(ref) || isCheckBoxInput(ref);\n\nclass Subscription {\n  constructor() {\n    this.tearDowns = [];\n  }\n\n  add(tearDown) {\n    this.tearDowns.push(tearDown);\n  }\n\n  unsubscribe() {\n    for (const teardown of this.tearDowns) {\n      teardown();\n    }\n\n    this.tearDowns = [];\n  }\n\n}\n\nclass Subscriber {\n  constructor(observer, subscription) {\n    this.observer = observer;\n    this.closed = false;\n    subscription.add(() => this.closed = true);\n  }\n\n  next(value) {\n    if (!this.closed) {\n      this.observer.next(value);\n    }\n  }\n\n}\n\nclass Subject {\n  constructor() {\n    this.observers = [];\n  }\n\n  next(value) {\n    for (const observer of this.observers) {\n      observer.next(value);\n    }\n  }\n\n  subscribe(observer) {\n    const subscription = new Subscription();\n    const subscriber = new Subscriber(observer, subscription);\n    this.observers.push(subscriber);\n    return subscription;\n  }\n\n  unsubscribe() {\n    this.observers = [];\n  }\n\n}\n\nconst isWindowUndefined = typeof window === 'undefined';\n\nfunction useForm({\n  mode = VALIDATION_MODE.onSubmit,\n  reValidateMode = VALIDATION_MODE.onChange,\n  resolver,\n  context,\n  defaultValues = {},\n  shouldFocusError = true,\n  shouldUnregister,\n  criteriaMode\n} = {}) {\n  const fieldsRef = React.useRef({});\n  const fieldsNamesRef = React.useRef(new Set());\n  const formStateSubjectRef = React.useRef(new Subject());\n  const unregisterFieldsNamesRef = React.useRef(new Set());\n  const watchSubjectRef = React.useRef(new Subject());\n  const controllerSubjectRef = React.useRef(new Subject());\n  const fieldArraySubjectRef = React.useRef(new Subject());\n  const fieldArrayDefaultValuesRef = React.useRef({});\n  const inFieldArrayActionRef = React.useRef(false);\n  const watchFieldsRef = React.useRef(new Set());\n  const isMountedRef = React.useRef(false);\n  const fieldsWithValidationRef = React.useRef({});\n  const validFieldsRef = React.useRef({});\n  const defaultValuesRef = React.useRef(defaultValues);\n  const isWatchAllRef = React.useRef(false);\n  const contextRef = React.useRef(context);\n  const resolverRef = React.useRef(resolver);\n  const fieldArrayNamesRef = React.useRef(new Set());\n  const validationMode = getValidationModes(mode);\n  const isValidateAllFieldCriteria = criteriaMode === VALIDATION_MODE.all;\n  const [formState, updateFormState] = React.useState({\n    isDirty: false,\n    isValidating: false,\n    dirtyFields: {},\n    isSubmitted: false,\n    submitCount: 0,\n    touchedFields: {},\n    isSubmitting: false,\n    isSubmitSuccessful: false,\n    isValid: !validationMode.isOnSubmit,\n    errors: {}\n  });\n  const readFormStateRef = React.useRef({\n    isDirty: !isProxyEnabled,\n    dirtyFields: !isProxyEnabled,\n    touchedFields: !isProxyEnabled,\n    isValidating: !isProxyEnabled,\n    isValid: !isProxyEnabled,\n    errors: !isProxyEnabled\n  });\n  const formStateRef = React.useRef(formState);\n  contextRef.current = context;\n  resolverRef.current = resolver;\n\n  const getIsValid = () => {\n    formStateRef.current.isValid = deepEqual(validFieldsRef.current, fieldsWithValidationRef.current) && isEmptyObject(formStateRef.current.errors);\n    return formStateRef.current.isValid;\n  };\n\n  const shouldRenderBaseOnError = React.useCallback((name, error, shouldRender = false, state = {}, isValid, isWatched) => {\n    const previousError = get(formStateRef.current.errors, name);\n\n    if (error) {\n      unset(validFieldsRef.current, name);\n      set(formStateRef.current.errors, name, error);\n    } else {\n      (get(fieldsWithValidationRef.current, name) || resolverRef.current) && set(validFieldsRef.current, name, true);\n      unset(formStateRef.current.errors, name);\n    }\n\n    if ((shouldRender || isWatched || (error ? !deepEqual(previousError, error, true) : previousError) || !isEmptyObject(state) || readFormStateRef.current.isValid && formStateRef.current.isValid !== (resolverRef.current ? !!isValid : getIsValid())) && !isNullOrUndefined(shouldRender)) {\n      const updatedFormState = Object.assign(Object.assign({}, state), {\n        isValid: resolverRef.current ? !!isValid : getIsValid(),\n        errors: formStateRef.current.errors,\n        name\n      });\n      formStateRef.current = Object.assign(Object.assign({}, formStateRef.current), updatedFormState);\n      formStateSubjectRef.current.next(isWatched ? {\n        name\n      } : updatedFormState);\n    }\n\n    formStateSubjectRef.current.next({\n      isValidating: false\n    });\n  }, []);\n  const setFieldValue = React.useCallback((name, rawValue, options = {}, shouldRender, shouldRegister) => {\n    shouldRegister && register(name);\n    const field = get(fieldsRef.current, name);\n\n    if (field) {\n      const _f = field._f;\n\n      if (_f) {\n        const value = isWeb && isHTMLElement(_f.ref) && isNullOrUndefined(rawValue) ? '' : rawValue;\n        _f.value = getFieldValueAs(rawValue, _f);\n\n        if (isRadioInput(_f.ref)) {\n          (_f.refs || []).forEach(radioRef => radioRef.checked = radioRef.value === value);\n        } else if (isFileInput(_f.ref) && !isString(value)) {\n          _f.ref.files = value;\n        } else if (isMultipleSelect(_f.ref)) {\n          [..._f.ref.options].forEach(selectRef => selectRef.selected = value.includes(selectRef.value));\n        } else if (isCheckBoxInput(_f.ref) && _f.refs) {\n          _f.refs.length > 1 ? _f.refs.forEach(checkboxRef => checkboxRef.checked = Array.isArray(value) ? !!value.find(data => data === checkboxRef.value) : value === checkboxRef.value) : _f.refs[0].checked = !!value;\n        } else {\n          _f.ref.value = value;\n        }\n\n        if (shouldRender) {\n          const values = getFieldsValues(fieldsRef);\n          set(values, name, rawValue);\n          controllerSubjectRef.current.next({\n            values: Object.assign(Object.assign({}, defaultValuesRef.current), values),\n            name\n          });\n        }\n\n        options.shouldDirty && updateAndGetDirtyState(name, value);\n        options.shouldValidate && trigger(name);\n      } else {\n        field._f = {\n          ref: {\n            name,\n            value: rawValue\n          },\n          value: rawValue\n        };\n      }\n    }\n  }, []);\n  const getIsDirty = React.useCallback((name, data) => {\n    const formValues = getFieldsValues(fieldsRef);\n    name && data && set(formValues, name, data);\n    return !deepEqual(formValues, defaultValuesRef.current);\n  }, []);\n  const updateAndGetDirtyState = React.useCallback((name, inputValue, shouldRender = true) => {\n    if (readFormStateRef.current.isDirty || readFormStateRef.current.dirtyFields) {\n      const isFieldDirty = !deepEqual(get(defaultValuesRef.current, name), inputValue);\n      const isDirtyFieldExist = get(formStateRef.current.dirtyFields, name);\n      const previousIsDirty = formStateRef.current.isDirty;\n      isFieldDirty ? set(formStateRef.current.dirtyFields, name, true) : unset(formStateRef.current.dirtyFields, name);\n      formStateRef.current.isDirty = getIsDirty();\n      const state = {\n        isDirty: formStateRef.current.isDirty,\n        dirtyFields: formStateRef.current.dirtyFields,\n        name\n      };\n      const isChanged = readFormStateRef.current.isDirty && previousIsDirty !== state.isDirty || readFormStateRef.current.dirtyFields && isDirtyFieldExist !== get(formStateRef.current.dirtyFields, name);\n      isChanged && shouldRender && formStateSubjectRef.current.next(state);\n      return isChanged ? state : {};\n    }\n\n    return {};\n  }, []);\n  const executeValidation = React.useCallback(async (name, skipReRender) => {\n    const error = (await validateField(get(fieldsRef.current, name), isValidateAllFieldCriteria))[name];\n    shouldRenderBaseOnError(name, error, skipReRender);\n    return isUndefined(error);\n  }, [isValidateAllFieldCriteria]);\n  const executeSchemaOrResolverValidation = React.useCallback(async (names, currentNames = []) => {\n    const {\n      errors\n    } = await resolverRef.current(getFieldsValues(fieldsRef), contextRef.current, {\n      criteriaMode,\n      names: currentNames,\n      fields: getFields(fieldsNamesRef.current, fieldsRef.current)\n    });\n\n    for (const name of names) {\n      const error = get(errors, name);\n      error ? set(formStateRef.current.errors, name, error) : unset(formStateRef.current.errors, name);\n    }\n\n    return errors;\n  }, [criteriaMode]);\n\n  const validateForm = async fieldsRef => {\n    for (const name in fieldsRef) {\n      const field = fieldsRef[name];\n\n      if (field) {\n        const _f = field._f;\n        const current = omit(field, '_f');\n\n        if (_f) {\n          const fieldError = await validateField(field, isValidateAllFieldCriteria);\n\n          if (fieldError[_f.name]) {\n            set(formStateRef.current.errors, _f.name, fieldError[_f.name]);\n            unset(validFieldsRef.current, _f.name);\n          } else if (get(fieldsWithValidationRef.current, _f.name)) {\n            set(validFieldsRef.current, _f.name, true);\n            unset(formStateRef.current.errors, _f.name);\n          }\n        }\n\n        current && (await validateForm(current));\n      }\n    }\n  };\n\n  const trigger = React.useCallback(async (name, options = {}) => {\n    const fieldNames = isUndefined(name) ? Object.keys(fieldsRef.current) : convertToArrayPayload(name);\n    let isValid;\n    let schemaResult = {};\n    formStateSubjectRef.current.next({\n      isValidating: true\n    });\n\n    if (resolverRef.current) {\n      schemaResult = await executeSchemaOrResolverValidation(fieldNames, isUndefined(name) ? undefined : fieldNames);\n      isValid = fieldNames.every(name => !get(schemaResult, name));\n    } else {\n      if (isUndefined(name)) {\n        await validateForm(fieldsRef.current);\n        isValid = isEmptyObject(formStateRef.current.errors);\n      } else {\n        isValid = (await Promise.all(fieldNames.filter(fieldName => get(fieldsRef.current, fieldName)).map(async fieldName => await executeValidation(fieldName, null)))).every(Boolean);\n      }\n    }\n\n    formStateSubjectRef.current.next(Object.assign(Object.assign({}, isString(name) ? {\n      name\n    } : {}), {\n      errors: formStateRef.current.errors,\n      isValidating: false,\n      isValid: resolverRef.current ? isEmptyObject(schemaResult) : getIsValid()\n    }));\n\n    if (!isValid && options.shouldFocus) {\n      focusFieldBy(fieldsRef.current, key => get(formStateRef.current.errors, key), fieldNames);\n    }\n\n    return isValid;\n  }, [executeSchemaOrResolverValidation, executeValidation]);\n  const setInternalValues = React.useCallback((name, value, options) => Object.entries(value).forEach(([inputKey, inputValue]) => {\n    const fieldName = `${name}.${inputKey}`;\n    const field = get(fieldsRef.current, fieldName);\n    const isFieldArray = fieldArrayNamesRef.current.has(name);\n    isFieldArray || !isPrimitive(inputValue) || field && !field._f ? setInternalValues(fieldName, inputValue, options) : setFieldValue(fieldName, inputValue, options, true, !field);\n  }), [trigger]);\n\n  const isFieldWatched = name => isWatchAllRef.current || watchFieldsRef.current.has(name) || watchFieldsRef.current.has((name.match(/\\w+/) || [])[0]);\n\n  const updateValidAndValue = (name, options, ref, isWithinRefCallback) => {\n    const field = get(fieldsRef.current, name);\n    const defaultValue = isUndefined(field._f.value) ? get(defaultValuesRef.current, name) : field._f.value;\n\n    if (field && !isUndefined(defaultValue)) {\n      if (ref && ref.defaultChecked) {\n        field._f.value = getFieldValue(field);\n      } else if (!isNameInFieldArray(fieldArrayNamesRef.current, name)) {\n        setFieldValue(name, defaultValue);\n      } else {\n        field._f.value = defaultValue;\n      }\n    } else {\n      field._f.value = getFieldValue(field);\n    }\n\n    if ((!isUndefined(defaultValue) || isWithinRefCallback) && hasValidation(options, field._f.mount) && !validationMode.isOnSubmit && field && readFormStateRef.current.isValid) {\n      validateField(field, isValidateAllFieldCriteria).then(error => {\n        isEmptyObject(error) ? set(validFieldsRef.current, name, true) : unset(validFieldsRef.current, name);\n        formStateRef.current.isValid !== getIsValid() && updateFormState(Object.assign(Object.assign({}, formStateRef.current), {\n          isValid: getIsValid()\n        }));\n      });\n    }\n\n    return defaultValue;\n  };\n\n  const setValue = (name, value, options = {}) => {\n    const field = get(fieldsRef.current, name);\n    const isFieldArray = fieldArrayNamesRef.current.has(name);\n\n    if (isFieldArray) {\n      fieldArraySubjectRef.current.next({\n        fields: value,\n        name,\n        isReset: true\n      });\n\n      if ((readFormStateRef.current.isDirty || readFormStateRef.current.dirtyFields) && options.shouldDirty) {\n        set(formStateRef.current.dirtyFields, name, setFieldArrayDirtyFields(value, get(defaultValuesRef.current, name, []), get(formStateRef.current.dirtyFields, name, [])));\n        formStateSubjectRef.current.next({\n          name,\n          dirtyFields: formStateRef.current.dirtyFields,\n          isDirty: getIsDirty(name, value)\n        });\n      }\n\n      !value.length && set(fieldsRef.current, name, []) && set(fieldArrayDefaultValuesRef.current, name, []);\n    }\n\n    (field && !field._f || isFieldArray) && !isNullOrUndefined(value) ? setInternalValues(name, value, isFieldArray ? {} : options) : setFieldValue(name, value, options, true, !field);\n    isFieldWatched(name) && formStateSubjectRef.current.next({});\n    watchSubjectRef.current.next({\n      name,\n      formValues: getValues()\n    });\n  };\n\n  const handleChange = React.useCallback(async ({\n    type,\n    target,\n    target: {\n      value,\n      type: inputType\n    }\n  }) => {\n    let name = target.name;\n    let error;\n    let isValid;\n    const field = get(fieldsRef.current, name);\n\n    if (field) {\n      let inputValue = inputType ? getFieldValue(field) : undefined;\n      inputValue = isUndefined(inputValue) ? value : inputValue;\n      const isBlurEvent = type === EVENTS.BLUR;\n      const {\n        isOnBlur: isReValidateOnBlur,\n        isOnChange: isReValidateOnChange\n      } = getValidationModes(reValidateMode);\n      const shouldSkipValidation = !hasValidation(field._f, field._f.mount) && !resolverRef.current && !get(formStateRef.current.errors, name) || skipValidation(Object.assign({\n        isBlurEvent,\n        isTouched: !!get(formStateRef.current.touchedFields, name),\n        isSubmitted: formStateRef.current.isSubmitted,\n        isReValidateOnBlur,\n        isReValidateOnChange\n      }, validationMode));\n      const isWatched = !isBlurEvent && isFieldWatched(name);\n\n      if (!isUndefined(inputValue)) {\n        field._f.value = inputValue;\n      }\n\n      const state = updateAndGetDirtyState(name, field._f.value, false);\n\n      if (isBlurEvent && !get(formStateRef.current.touchedFields, name)) {\n        set(formStateRef.current.touchedFields, name, true);\n        readFormStateRef.current.touchedFields && (state.touchedFields = formStateRef.current.touchedFields);\n      }\n\n      let shouldRender = !isEmptyObject(state) || isWatched;\n\n      if (shouldSkipValidation) {\n        !isBlurEvent && watchSubjectRef.current.next({\n          name,\n          type,\n          formValues: getValues()\n        });\n        return shouldRender && formStateSubjectRef.current.next(isWatched ? {\n          name\n        } : Object.assign(Object.assign({}, state), {\n          name\n        }));\n      }\n\n      formStateSubjectRef.current.next({\n        isValidating: true\n      });\n\n      if (resolverRef.current) {\n        const {\n          errors\n        } = await resolverRef.current(getFieldsValues(fieldsRef), contextRef.current, {\n          criteriaMode,\n          fields: getFields([name], fieldsRef.current),\n          names: [name]\n        });\n        const previousFormIsValid = formStateRef.current.isValid;\n        error = get(errors, name);\n\n        if (isCheckBoxInput(target) && !error) {\n          const parentNodeName = getNodeParentName(name);\n          const currentError = get(errors, parentNodeName, {});\n          currentError.type && currentError.message && (error = currentError);\n\n          if (currentError || get(formStateRef.current.errors, parentNodeName)) {\n            name = parentNodeName;\n          }\n        }\n\n        isValid = isEmptyObject(errors);\n        previousFormIsValid !== isValid && (shouldRender = true);\n      } else {\n        error = (await validateField(field, isValidateAllFieldCriteria))[name];\n      }\n\n      !isBlurEvent && watchSubjectRef.current.next({\n        name,\n        type,\n        formValues: getValues()\n      });\n      shouldRenderBaseOnError(name, error, shouldRender, state, isValid, isWatched);\n    }\n  }, []);\n\n  const getValues = fieldNames => {\n    const values = Object.assign(Object.assign({}, defaultValuesRef.current), getFieldsValues(fieldsRef));\n    return isUndefined(fieldNames) ? values : isString(fieldNames) ? get(values, fieldNames) : fieldNames.map(name => get(values, name));\n  };\n\n  const updateIsValid = React.useCallback(async (values = {}) => {\n    const previousIsValid = formStateRef.current.isValid;\n\n    if (resolver) {\n      const {\n        errors\n      } = await resolverRef.current(Object.assign(Object.assign({}, getFieldsValues(fieldsRef)), values), contextRef.current, {\n        criteriaMode,\n        fields: getFields(fieldsNamesRef.current, fieldsRef.current)\n      });\n      formStateRef.current.isValid = isEmptyObject(errors);\n    } else {\n      getIsValid();\n    }\n\n    previousIsValid !== formStateRef.current.isValid && formStateSubjectRef.current.next({\n      isValid: formStateRef.current.isValid\n    });\n  }, [criteriaMode]);\n\n  const clearErrors = name => {\n    name ? convertToArrayPayload(name).forEach(inputName => unset(formStateRef.current.errors, inputName)) : formStateRef.current.errors = {};\n    formStateSubjectRef.current.next({\n      errors: formStateRef.current.errors\n    });\n  };\n\n  const setError = (name, error, options) => {\n    const ref = ((get(fieldsRef.current, name) || {\n      _f: {}\n    })._f || {}).ref;\n    set(formStateRef.current.errors, name, Object.assign(Object.assign({}, error), {\n      ref\n    }));\n    formStateSubjectRef.current.next({\n      name,\n      errors: formStateRef.current.errors,\n      isValid: false\n    });\n    options && options.shouldFocus && ref && ref.focus && ref.focus();\n  };\n\n  const watchInternal = React.useCallback((fieldNames, defaultValue, isGlobal, formValues) => {\n    const isArrayNames = Array.isArray(fieldNames);\n    const fieldValues = formValues || isMountedRef.current ? Object.assign(Object.assign({}, defaultValuesRef.current), formValues || getFieldsValues(fieldsRef)) : isUndefined(defaultValue) ? defaultValuesRef.current : isArrayNames ? defaultValue : {\n      [fieldNames]: defaultValue\n    };\n\n    if (isUndefined(fieldNames)) {\n      isGlobal && (isWatchAllRef.current = true);\n      return fieldValues;\n    }\n\n    const result = [];\n\n    for (const fieldName of convertToArrayPayload(fieldNames)) {\n      isGlobal && watchFieldsRef.current.add(fieldName);\n      result.push(get(fieldValues, fieldName));\n    }\n\n    return isArrayNames ? result : result[0];\n  }, []);\n\n  const watch = (fieldName, defaultValue) => isFunction(fieldName) ? watchSubjectRef.current.subscribe({\n    next: info => fieldName(watchInternal(undefined, defaultValue), info)\n  }) : watchInternal(fieldName, defaultValue, true);\n\n  const unregister = (name, options = {}) => {\n    for (const inputName of name ? convertToArrayPayload(name) : Object.keys(fieldsNamesRef.current)) {\n      fieldsNamesRef.current.delete(inputName);\n      fieldArrayNamesRef.current.delete(inputName);\n\n      if (get(fieldsRef.current, inputName)) {\n        if (!options.keepIsValid) {\n          unset(fieldsWithValidationRef.current, inputName);\n          unset(validFieldsRef.current, inputName);\n        }\n\n        !options.keepError && unset(formStateRef.current.errors, inputName);\n        !options.keepValue && unset(fieldsRef.current, inputName);\n        !options.keepDirty && unset(formStateRef.current.dirtyFields, inputName);\n        !options.keepTouched && unset(formStateRef.current.touchedFields, inputName);\n        !shouldUnregister && !options.keepDefaultValue && unset(defaultValuesRef.current, inputName);\n        watchSubjectRef.current.next({\n          name: inputName,\n          formValues: getValues()\n        });\n      }\n    }\n\n    formStateSubjectRef.current.next(Object.assign(Object.assign(Object.assign({}, formStateRef.current), !options.keepDirty ? {} : {\n      isDirty: getIsDirty()\n    }), resolverRef.current ? {} : {\n      isValid: getIsValid()\n    }));\n    !options.keepIsValid && updateIsValid();\n  };\n\n  const registerFieldRef = (name, ref, options) => {\n    register(name, options);\n    let field = get(fieldsRef.current, name);\n    const isRadioOrCheckbox = isRadioOrCheckboxFunction(ref);\n\n    if (ref === field._f.ref || isWeb && isHTMLElement(field._f.ref) && !isHTMLElement(ref) || isRadioOrCheckbox && Array.isArray(field._f.refs) && compact(field._f.refs).find(option => option === ref)) {\n      return;\n    }\n\n    field = {\n      _f: isRadioOrCheckbox ? Object.assign(Object.assign({}, field._f), {\n        refs: [...compact(field._f.refs || []).filter(ref => isHTMLElement(ref) && document.contains(ref)), ref],\n        ref: {\n          type: ref.type,\n          name\n        }\n      }) : Object.assign(Object.assign({}, field._f), {\n        ref\n      })\n    };\n    set(fieldsRef.current, name, field);\n    const defaultValue = updateValidAndValue(name, options, ref, true);\n\n    if (isRadioOrCheckbox && Array.isArray(defaultValue) ? !deepEqual(get(fieldsRef.current, name)._f.value, defaultValue) : isUndefined(get(fieldsRef.current, name)._f.value)) {\n      get(fieldsRef.current, name)._f.value = getFieldValue(get(fieldsRef.current, name));\n    }\n  };\n\n  const register = React.useCallback((name, options = {}) => {\n    const field = get(fieldsRef.current, name);\n    set(fieldsRef.current, name, {\n      _f: Object.assign(Object.assign(Object.assign({}, field && field._f ? field._f : {\n        ref: {\n          name\n        }\n      }), {\n        name,\n        mount: true\n      }), options)\n    });\n    hasValidation(options, true) && set(fieldsWithValidationRef.current, name, true);\n    fieldsNamesRef.current.add(name);\n    !field && updateValidAndValue(name, options);\n    return isWindowUndefined ? {\n      name: name\n    } : {\n      name,\n      onChange: handleChange,\n      onBlur: handleChange,\n      ref: ref => {\n        if (ref) {\n          registerFieldRef(name, ref, options);\n        } else {\n          const field = get(fieldsRef.current, name, {});\n          const shouldUnmount = shouldUnregister || options.shouldUnregister;\n\n          if (field._f) {\n            field._f.mount = false; // If initial state of field element is disabled,\n            // value is not set on first \"register\"\n            // re-sync the value in when it switched to enabled\n\n            if (isUndefined(field._f.value)) {\n              field._f.value = field._f.ref.value;\n            }\n          }\n\n          if (isNameInFieldArray(fieldArrayNamesRef.current, name) ? shouldUnmount && !inFieldArrayActionRef.current : shouldUnmount) {\n            unregisterFieldsNamesRef.current.add(name);\n          }\n        }\n      }\n    };\n  }, []);\n  const handleSubmit = React.useCallback((onValid, onInvalid) => async e => {\n    if (e) {\n      e.preventDefault && e.preventDefault();\n      e.persist && e.persist();\n    }\n\n    let hasNoPromiseError = true;\n    let fieldValues = getFieldsValues(fieldsRef);\n    formStateSubjectRef.current.next({\n      isSubmitting: true\n    });\n\n    try {\n      if (resolverRef.current) {\n        const {\n          errors,\n          values\n        } = await resolverRef.current(fieldValues, contextRef.current, {\n          criteriaMode,\n          fields: getFields(fieldsNamesRef.current, fieldsRef.current)\n        });\n        formStateRef.current.errors = errors;\n        fieldValues = values;\n      } else {\n        await validateForm(fieldsRef.current);\n      }\n\n      if (isEmptyObject(formStateRef.current.errors) && Object.keys(formStateRef.current.errors).every(name => get(fieldValues, name))) {\n        formStateSubjectRef.current.next({\n          errors: {},\n          isSubmitting: true\n        });\n        await onValid(fieldValues, e);\n      } else {\n        onInvalid && (await onInvalid(formStateRef.current.errors, e));\n        shouldFocusError && focusFieldBy(fieldsRef.current, key => get(formStateRef.current.errors, key), fieldsNamesRef.current);\n      }\n    } catch (err) {\n      hasNoPromiseError = false;\n      throw err;\n    } finally {\n      formStateRef.current.isSubmitted = true;\n      formStateSubjectRef.current.next({\n        isSubmitted: true,\n        isSubmitting: false,\n        isSubmitSuccessful: isEmptyObject(formStateRef.current.errors) && hasNoPromiseError,\n        submitCount: formStateRef.current.submitCount + 1,\n        errors: formStateRef.current.errors\n      });\n    }\n  }, [shouldFocusError, isValidateAllFieldCriteria, criteriaMode]);\n  const resetFromState = React.useCallback(({\n    keepErrors,\n    keepDirty,\n    keepIsSubmitted,\n    keepTouched,\n    keepDefaultValues,\n    keepIsValid,\n    keepSubmitCount\n  }, values) => {\n    if (!keepIsValid) {\n      validFieldsRef.current = {};\n      fieldsWithValidationRef.current = {};\n    }\n\n    watchFieldsRef.current = new Set();\n    isWatchAllRef.current = false;\n    formStateSubjectRef.current.next({\n      submitCount: keepSubmitCount ? formStateRef.current.submitCount : 0,\n      isDirty: keepDirty ? formStateRef.current.isDirty : keepDefaultValues ? deepEqual(values, defaultValuesRef.current) : false,\n      isSubmitted: keepIsSubmitted ? formStateRef.current.isSubmitted : false,\n      isValid: keepIsValid ? formStateRef.current.isValid : !!updateIsValid(values),\n      dirtyFields: keepDirty ? formStateRef.current.dirtyFields : {},\n      touchedFields: keepTouched ? formStateRef.current.touchedFields : {},\n      errors: keepErrors ? formStateRef.current.errors : {},\n      isSubmitting: false,\n      isSubmitSuccessful: false\n    });\n  }, []);\n\n  const registerAbsentFields = (value, name = '') => {\n    const field = get(fieldsRef.current, name);\n\n    if (!field || field && !field._f) {\n      if (!field && (isPrimitive(value) || isWeb && (value instanceof FileList || value instanceof Date))) {\n        set(fieldsRef.current, name, {\n          _f: {\n            ref: {\n              name,\n              value\n            },\n            value,\n            name\n          }\n        });\n      }\n\n      if (Array.isArray(value) || isObject(value)) {\n        if (name && !get(fieldsRef.current, name)) {\n          set(fieldsRef.current, name, Array.isArray(value) ? [] : {});\n        }\n\n        for (const key in value) {\n          registerAbsentFields(value[key], name + (name ? '.' : '') + key);\n        }\n      }\n    }\n  };\n\n  const reset = (values, keepStateOptions = {}) => {\n    const updatedValues = values || defaultValuesRef.current;\n\n    if (isWeb && !keepStateOptions.keepValues) {\n      for (const name of fieldsNamesRef.current) {\n        const field = get(fieldsRef.current, name);\n\n        if (field && field._f) {\n          const inputRef = Array.isArray(field._f.refs) ? field._f.refs[0] : field._f.ref;\n\n          try {\n            isHTMLElement(inputRef) && inputRef.closest('form').reset();\n            break;\n          } catch (_a) {}\n        }\n      }\n    }\n\n    !keepStateOptions.keepDefaultValues && (defaultValuesRef.current = Object.assign({}, updatedValues));\n\n    if (!keepStateOptions.keepValues) {\n      fieldsRef.current = {};\n      controllerSubjectRef.current.next({\n        values: Object.assign({}, updatedValues)\n      });\n      watchSubjectRef.current.next({\n        formValues: Object.assign({}, updatedValues)\n      });\n      fieldArraySubjectRef.current.next({\n        fields: Object.assign({}, updatedValues),\n        isReset: true\n      });\n    }\n\n    !keepStateOptions.keepDefaultValues && !shouldUnregister && registerAbsentFields(Object.assign({}, updatedValues));\n    resetFromState(keepStateOptions, values);\n  };\n\n  const setFocus = name => get(fieldsRef.current, name)._f.ref.focus();\n\n  React.useEffect(() => {\n    !shouldUnregister && registerAbsentFields(defaultValuesRef.current);\n    const formStateSubscription = formStateSubjectRef.current.subscribe({\n      next(formState) {\n        if (shouldRenderFormState(formState, readFormStateRef.current, true)) {\n          formStateRef.current = Object.assign(Object.assign({}, formStateRef.current), formState);\n          updateFormState(formStateRef.current);\n        }\n      }\n\n    });\n    const useFieldArraySubscription = fieldArraySubjectRef.current.subscribe({\n      next(state) {\n        if (state.fields && state.name && readFormStateRef.current.isValid) {\n          const values = getFieldsValues(fieldsRef);\n          set(values, state.name, state.fields);\n          updateIsValid(values);\n        }\n      }\n\n    });\n    resolverRef.current && readFormStateRef.current.isValid && updateIsValid();\n    return () => {\n      watchSubjectRef.current.unsubscribe();\n      formStateSubscription.unsubscribe();\n      useFieldArraySubscription.unsubscribe();\n    };\n  }, []);\n  React.useEffect(() => {\n    const isLiveInDom = ref => !isHTMLElement(ref) || !document.contains(ref);\n\n    isMountedRef.current = true;\n\n    for (const name of unregisterFieldsNamesRef.current) {\n      const field = get(fieldsRef.current, name);\n      field && (field._f.refs ? field._f.refs.every(isLiveInDom) : isLiveInDom(field._f.ref)) && unregister(name);\n    }\n\n    unregisterFieldsNamesRef.current = new Set();\n  });\n  return {\n    control: React.useMemo(() => ({\n      register,\n      isWatchAllRef,\n      inFieldArrayActionRef,\n      watchFieldsRef,\n      getIsDirty,\n      formStateSubjectRef,\n      fieldArraySubjectRef,\n      controllerSubjectRef,\n      watchSubjectRef,\n      watchInternal,\n      fieldsRef,\n      validFieldsRef,\n      fieldsWithValidationRef,\n      fieldArrayNamesRef,\n      readFormStateRef,\n      formStateRef,\n      defaultValuesRef,\n      fieldArrayDefaultValuesRef,\n      unregister,\n      shouldUnmount: shouldUnregister\n    }), []),\n    formState: getProxyFormState(isProxyEnabled, formState, readFormStateRef),\n    trigger,\n    register,\n    handleSubmit,\n    watch: React.useCallback(watch, []),\n    setValue: React.useCallback(setValue, [setInternalValues]),\n    getValues: React.useCallback(getValues, []),\n    reset: React.useCallback(reset, []),\n    clearErrors: React.useCallback(clearErrors, []),\n    unregister: React.useCallback(unregister, []),\n    setError: React.useCallback(setError, []),\n    setFocus: React.useCallback(setFocus, [])\n  };\n}\n\nexport { EmailInput as E, Form$1 as F, HeaderText$1 as H, Input as I, Label$1 as L, PasswordInput as P, Spacer as S, TextButton$1 as T, SubmitButton$1 as a, SecondaryButton$1 as b, useForm as u };","map":{"version":3,"sources":["../src/ui/Auth/components/Form.tsx","../src/ui/Auth/components/internal/Label.tsx","../src/ui/Auth/components/internal/Input.tsx","../src/ui/Auth/components/EmailInput.tsx","../src/ui/Auth/components/PasswordInput.tsx","../src/ui/Auth/components/HeaderText.tsx","../src/ui/Auth/components/internal/TextButton.tsx","../src/ui/Auth/components/SecondaryButton.tsx","../src/ui/Auth/components/SubmitButton.tsx","../src/ui/Auth/components/Spacer.tsx","../node_modules/react-hook-form/dist/index.esm.js"],"names":["Form","styled","props","display","justifyContent","minWidth","width","padding","boxShadow","borderRadius","flexDirection","fontFamily","margin","position","top","left","right","bottom","React","Label","TextFieldRoot","maxWidth","height","TextField","background","border","Bar","placeholder","id","htmlFor","label","autoComplete","type","required","HeaderText","fontSize","fontWeight","letterSpacing","marginBlockStart","marginBlockEnd","marginInlineStart","marginInlineEnd","marginTop","TextButton","cursor","color","whiteSpace","SecondaryButton","SubmitButtonRoot","SubmitButton","verticalAlign","textAlign","textOverflow","overflow","outline","boxSizing","style"],"mappings":"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","sourcesContent":["import React from 'react';\nimport styled from 'styled-components';\n\nconst Form = styled.form(props => ({\n    display: \"flex\",\n    justifyContent: \"center\",\n    minWidth: 300,\n    width: 380,\n    padding: '33px 55px',\n    boxShadow: '0 5px 10px 0 rgb(0 0 0 / 10%)',\n    borderRadius: 10,\n    flexDirection: 'column',\n    fontFamily: \"inherit\",\n    margin: '6% auto 50px',\n    '@media (max-width: 520px)': {\n        margin: '0px !important',\n        position: 'fixed !important',\n        top: 0,\n        left: 0,\n        right: 0,\n        bottom: 0,\n        width: 'initial !important'\n    },\n    ...(props.theme.form ? { ...props.theme.form } : {})\n}))\n\nexport default function (props: React.FormHTMLAttributes<HTMLFormElement>) {\n    return (\n        <Form {...props}>{props.children}</Form>\n    )\n}\n","import React from 'react';\nimport styled from 'styled-components';\n\nconst Label = styled.label(props => ({\n    display: \"none\",\n    fontFamily: \"inherit\",\n    ...(props.theme.textFieldLabel ? { ...props.theme.textFieldLabel } : {})\n}))\n\nexport default function (props: React.LabelHTMLAttributes<HTMLLabelElement>) {\n    return (<Label {...props} />)\n}\n","import React from 'react';\nimport { UseFormRegisterReturn } from 'react-hook-form';\nimport styled from 'styled-components';\nimport Label from './Label';\n\nconst TextFieldRoot = styled.div(props => ({\n    position: 'relative',\n    width: '100%',\n    maxWidth: '100%',\n    padding: 0,\n    height: 46,\n    fontFamily: \"inherit\",\n    ...(props.theme.textFieldRoot ? { ...props.theme.textFieldRoot } : {})\n}))\n\nconst TextField = styled.input(props => ({\n    display: \"block\",\n    width: '100%',\n    background: '0 0',\n    border: 'none',\n    fontFamily: \"inherit\",\n    ...(props.theme.textField ? { ...props.theme.textField } : {})\n}))\n\nconst Bar = styled.div(props => props.theme.textFieldBar ? { ...props.theme.textFieldBar } : {})\n\ninterface ITextField extends React.InputHTMLAttributes<HTMLInputElement> {\n    label: string\n    register(): UseFormRegisterReturn\n}\n\nexport default function (props: ITextField) {\n    return (\n        <TextFieldRoot>\n            <TextField placeholder=\"&nbsp;\" {...props} {...props.register()} id={\"textField-\" + props.label.replace(/[^a-zA-Z]+/g, '')} />\n            <Bar />\n            <Label htmlFor={\"textField-\" + props.label.replace(/[^a-zA-Z]+/g, '')}>{props.label}</Label>\n        </TextFieldRoot>\n    )\n}\n","import React, { forwardRef } from 'react';\nimport { UseFormRegisterReturn } from 'react-hook-form';\nimport Input from './internal/Input';\n\ninterface ITextField extends React.InputHTMLAttributes<HTMLInputElement> {\n    label?: string\n    register(): UseFormRegisterReturn\n}\n\nexport default function(props: ITextField) {\n    return (\n        <Input label=\"Email\" autoComplete=\"email\" {...props} type=\"email\" required />\n    )\n}\n","import React from 'react';\nimport { UseFormRegisterReturn } from 'react-hook-form';\nimport Input from './internal/Input';\n\ninterface ITextField extends React.InputHTMLAttributes<HTMLInputElement> {\n    label?: string;\n    register(): UseFormRegisterReturn;\n}\n\nexport default function(props: ITextField) {\n    return (\n        <Input label=\"Password\" {...props} type=\"password\" required />\n    )\n}\n","import React from 'react';\nimport styled from 'styled-components';\n\nconst HeaderText = styled.h1(props => ({\n    fontFamily: \"inherit\",\n    fontSize: 24,\n    fontWeight: 500,\n    letterSpacing: -.2,\n    marginBlockStart: '0.67em',\n    marginBlockEnd: '0.67em',\n    marginInlineStart: 0,\n    marginInlineEnd: 0,\n    marginTop: '16px !important',\n    ...(props.theme.headerText ? { ...props.theme.headerText } : {})\n}))\n\nexport default function (props: React.HTMLAttributes<HTMLHeadingElement>) {\n    return (\n        <HeaderText {...props} />\n    )\n}\n","import React from 'react';\nimport styled from 'styled-components';\n\nconst TextButton = styled.button(props => ({\n    cursor: \"pointer\",\n    color: '#635bff',\n    whiteSpace: 'nowrap',\n    fontWeight: 500,\n    fontSize: 14,\n    margin: 0,\n    background: 'none',\n    border: 'none',\n    ...(props.theme.textButton ? { ...props.theme.textButton } : {})\n}))\n\nexport default function (props: React.ButtonHTMLAttributes<HTMLButtonElement>) {\n    return (\n        <TextButton {...props} type=\"button\" />\n    )\n}\n","import React from 'react';\nimport TextButton from './internal/TextButton';\nimport styled from 'styled-components';\n\nconst SecondaryButton = styled(TextButton)(props => ({\n    margin: '15px',\n    ...(props.theme.secondaryButton ? { ...props.theme.secondaryButton } : {})\n}))\n\nexport default function (props: React.ButtonHTMLAttributes<HTMLButtonElement>) {\n    return (\n        <SecondaryButton {...props} />\n    )\n}\n","import React from 'react';\nimport styled from 'styled-components';\n\nconst SubmitButtonRoot = styled.div(props => props.theme.submitButtonRoot ? props.theme.submitButtonRoot : {});\n\nconst SubmitButton = styled.button(props => ({\n    position: 'relative',\n    border: \"none\",\n    verticalAlign: \"middle\",\n    textAlign: \"center\",\n    textOverflow: \"ellipsis\",\n    overflow: \"hidden\",\n    outline: \"none\",\n    cursor: \"pointer\",\n    boxSizing: 'border-box',\n    ...(props.theme.submitButton ? { ...props.theme.submitButton } : {})\n}))\n\nexport default function (props: React.ButtonHTMLAttributes<HTMLButtonElement>) {\n    return (\n        <SubmitButtonRoot>\n            <SubmitButton type=\"submit\" {...props} />\n        </SubmitButtonRoot>\n    )\n}\n","import React from 'react';\n\ninterface ISpacer {\n    size?: \"xlarge\" | \"large\" | \"medium\" | \"small\"\n}\n\nexport default function (props: ISpacer) {\n    switch (props.size) {\n        case \"xlarge\":\n            return <div style={{ height: 64 }} />   \n        case \"large\":\n            return <div style={{ height: 58 }} />            \n        case \"small\":\n            return <div style={{ height: 16 }} />\n        default:\n            return <div style={{ height: 37 }} />\n    }\n}\n","import * as React from 'react';\n\nvar isCheckBoxInput = (element) => element.type === 'checkbox';\n\nvar isNullOrUndefined = (value) => value == null;\n\nconst isObjectType = (value) => typeof value === 'object';\r\nvar isObject = (value) => !isNullOrUndefined(value) &&\r\n    !Array.isArray(value) &&\r\n    isObjectType(value) &&\r\n    !(value instanceof Date);\n\nvar getControllerValue = (event) => isObject(event) && event.target\r\n    ? isCheckBoxInput(event.target)\r\n        ? event.target.checked\r\n        : event.target.value\r\n    : event;\n\nvar getNodeParentName = (name) => name.substring(0, name.search(/.\\d/)) || name;\n\nvar isNameInFieldArray = (names, name) => [...names].some((current) => getNodeParentName(name) === current);\n\nvar compact = (value) => value.filter(Boolean);\n\nvar isUndefined = (val) => val === undefined;\n\nvar get = (obj, path, defaultValue) => {\r\n    if (isObject(obj) && path) {\r\n        const result = compact(path.split(/[,[\\].]+?/)).reduce((result, key) => (isNullOrUndefined(result) ? result : result[key]), obj);\r\n        return isUndefined(result) || result === obj\r\n            ? isUndefined(obj[path])\r\n                ? defaultValue\r\n                : obj[path]\r\n            : result;\r\n    }\r\n    return undefined;\r\n};\n\nconst EVENTS = {\r\n    BLUR: 'blur',\r\n    CHANGE: 'change',\r\n};\r\nconst VALIDATION_MODE = {\r\n    onBlur: 'onBlur',\r\n    onChange: 'onChange',\r\n    onSubmit: 'onSubmit',\r\n    onTouched: 'onTouched',\r\n    all: 'all',\r\n};\r\nconst INPUT_VALIDATION_RULES = {\r\n    max: 'max',\r\n    min: 'min',\r\n    maxLength: 'maxLength',\r\n    minLength: 'minLength',\r\n    pattern: 'pattern',\r\n    required: 'required',\r\n    validate: 'validate',\r\n};\n\nvar omit = (source, key) => {\r\n    const copy = Object.assign({}, source);\r\n    delete copy[key];\r\n    return copy;\r\n};\n\nconst FormContext = React.createContext(null);\r\nFormContext.displayName = 'RHFContext';\r\nconst useFormContext = () => React.useContext(FormContext);\r\nconst FormProvider = (props) => (React.createElement(FormContext.Provider, { value: omit(props, 'children') }, props.children));\n\nvar getProxyFormState = (isProxyEnabled, formState, readFormStateRef, localReadFormStateRef, isRoot = true) => isProxyEnabled\r\n    ? new Proxy(formState, {\r\n        get: (obj, prop) => {\r\n            if (prop in obj) {\r\n                if (readFormStateRef.current[prop] !== VALIDATION_MODE.all) {\r\n                    readFormStateRef.current[prop] = isRoot\r\n                        ? VALIDATION_MODE.all\r\n                        : true;\r\n                }\r\n                localReadFormStateRef &&\r\n                    (localReadFormStateRef.current[prop] = true);\r\n                return obj[prop];\r\n            }\r\n            return undefined;\r\n        },\r\n    })\r\n    : formState;\n\nvar isEmptyObject = (value) => isObject(value) && !Object.keys(value).length;\n\nvar shouldRenderFormState = (formStateData, readFormStateRef, isRoot) => {\r\n    const formState = omit(formStateData, 'name');\r\n    return (isEmptyObject(formState) ||\r\n        Object.keys(formState).length >= Object.keys(readFormStateRef).length ||\r\n        Object.keys(formState).find((key) => readFormStateRef[key] ===\r\n            (isRoot ? VALIDATION_MODE.all : true)));\r\n};\n\nvar convertToArrayPayload = (value) => Array.isArray(value) ? value : [value];\n\nvar isWeb = typeof window !== 'undefined' &&\r\n    typeof window.HTMLElement !== 'undefined' &&\r\n    typeof document !== 'undefined';\n\nconst isProxyEnabled = isWeb ? 'Proxy' in window : typeof Proxy !== 'undefined';\n\nfunction useFormState(props) {\r\n    const { control, name } = props || {};\r\n    const methods = useFormContext();\r\n    const { formStateRef, formStateSubjectRef, readFormStateRef } = control || methods.control;\r\n    const nameRef = React.useRef(name);\r\n    nameRef.current = name;\r\n    const [formState, updateFormState] = React.useState(formStateRef.current);\r\n    const readFormState = React.useRef({\r\n        isDirty: false,\r\n        dirtyFields: false,\r\n        touchedFields: false,\r\n        isValidating: false,\r\n        isValid: false,\r\n        errors: false,\r\n    });\r\n    React.useEffect(() => {\r\n        const formStateSubscription = formStateSubjectRef.current.subscribe({\r\n            next: (formState) => (!nameRef.current ||\r\n                !formState.name ||\r\n                convertToArrayPayload(nameRef.current).includes(formState.name)) &&\r\n                shouldRenderFormState(formState, readFormState.current) &&\r\n                updateFormState(Object.assign(Object.assign({}, formStateRef.current), formState)),\r\n        });\r\n        return () => formStateSubscription.unsubscribe();\r\n    }, []);\r\n    return getProxyFormState(isProxyEnabled, formState, readFormStateRef, readFormState, false);\r\n}\n\nfunction useController({ name, rules, defaultValue, control, shouldUnregister, }) {\r\n    const methods = useFormContext();\r\n    const { defaultValuesRef, register, fieldsRef, unregister, fieldArrayNamesRef, controllerSubjectRef, shouldUnmount, inFieldArrayActionRef, } = control || methods.control;\r\n    const { onChange, onBlur, ref } = register(name, rules);\r\n    const isFieldArray = isNameInFieldArray(fieldArrayNamesRef.current, name);\r\n    const [value, setInputStateValue] = React.useState(isUndefined(get(fieldsRef.current, name)._f.value) || isFieldArray\r\n        ? isUndefined(defaultValue)\r\n            ? get(defaultValuesRef.current, name)\r\n            : defaultValue\r\n        : get(fieldsRef.current, name)._f.value);\r\n    const formState = useFormState({\r\n        control: control || methods.control,\r\n        name,\r\n    });\r\n    const field = get(fieldsRef.current, name);\r\n    field._f.value = value;\r\n    React.useEffect(() => {\r\n        const controllerSubscription = controllerSubjectRef.current.subscribe({\r\n            next: (data) => (!data.name || name === data.name) &&\r\n                setInputStateValue(get(data.values, name)),\r\n        });\r\n        return () => {\r\n            controllerSubscription.unsubscribe();\r\n            const shouldUnmountField = shouldUnmount || shouldUnregister;\r\n            if (isFieldArray\r\n                ? shouldUnmountField && !inFieldArrayActionRef.current\r\n                : shouldUnmountField) {\r\n                unregister(name);\r\n            }\r\n            else if (get(fieldsRef.current, name)) {\r\n                get(fieldsRef.current, name)._f.mount = false;\r\n            }\r\n        };\r\n    }, [name]);\r\n    return {\r\n        field: {\r\n            onChange: (event) => {\r\n                const value = getControllerValue(event);\r\n                setInputStateValue(value);\r\n                onChange({\r\n                    target: {\r\n                        value,\r\n                        name: name,\r\n                    },\r\n                    type: EVENTS.CHANGE,\r\n                });\r\n            },\r\n            onBlur: () => {\r\n                onBlur({\r\n                    target: {\r\n                        name: name,\r\n                    },\r\n                    type: EVENTS.BLUR,\r\n                });\r\n            },\r\n            name,\r\n            value,\r\n            ref: (elm) => elm && ref(elm),\r\n        },\r\n        formState,\r\n        fieldState: {\r\n            invalid: !!get(formState.errors, name),\r\n            isDirty: !!get(formState.dirtyFields, name),\r\n            isTouched: !!get(formState.touchedFields, name),\r\n            error: get(formState.errors, name),\r\n        },\r\n    };\r\n}\n\nconst Controller = (props) => props.render(useController(props));\n\nvar appendErrors = (name, validateAllFieldCriteria, errors, type, message) => validateAllFieldCriteria\r\n    ? Object.assign(Object.assign({}, errors[name]), { types: Object.assign(Object.assign({}, (errors[name] && errors[name].types ? errors[name].types : {})), { [type]: message || true }) }) : {};\n\nvar isKey = (value) => /^\\w*$/.test(value);\n\nvar stringToPath = (input) => compact(input.replace(/[\"|']|\\]/g, '').split(/\\.|\\[/));\n\nfunction set(object, path, value) {\r\n    let index = -1;\r\n    const tempPath = isKey(path) ? [path] : stringToPath(path);\r\n    const length = tempPath.length;\r\n    const lastIndex = length - 1;\r\n    while (++index < length) {\r\n        const key = tempPath[index];\r\n        let newValue = value;\r\n        if (index !== lastIndex) {\r\n            const objValue = object[key];\r\n            newValue =\r\n                isObject(objValue) || Array.isArray(objValue)\r\n                    ? objValue\r\n                    : !isNaN(+tempPath[index + 1])\r\n                        ? []\r\n                        : {};\r\n        }\r\n        object[key] = newValue;\r\n        object = object[key];\r\n    }\r\n    return object;\r\n}\n\nconst focusFieldBy = (fields, callback, fieldsNames) => {\r\n    for (const key of fieldsNames || Object.keys(fields)) {\r\n        const field = get(fields, key);\r\n        if (field) {\r\n            const _f = field._f;\r\n            const current = omit(field, '_f');\r\n            if (_f && callback(_f.name)) {\r\n                if (_f.ref.focus && isUndefined(_f.ref.focus())) {\r\n                    break;\r\n                }\r\n                else if (_f.refs) {\r\n                    _f.refs[0].focus();\r\n                    break;\r\n                }\r\n            }\r\n            else if (isObject(current)) {\r\n                focusFieldBy(current, callback);\r\n            }\r\n        }\r\n    }\r\n};\n\nconst getFieldsValues = (fieldsRef, output = {}) => {\r\n    for (const name in fieldsRef.current) {\r\n        const field = fieldsRef.current[name];\r\n        if (field && !isNullOrUndefined(output)) {\r\n            const _f = field._f;\r\n            const current = omit(field, '_f');\r\n            set(output, name, _f && _f.ref\r\n                ? _f.ref.disabled || (_f.refs && _f.refs.every((ref) => ref.disabled))\r\n                    ? undefined\r\n                    : _f.value\r\n                : Array.isArray(field)\r\n                    ? []\r\n                    : {});\r\n            current &&\r\n                getFieldsValues({\r\n                    current,\r\n                }, output[name]);\r\n        }\r\n    }\r\n    return output;\r\n};\n\nvar generateId = () => {\r\n    const d = typeof performance === 'undefined' ? Date.now() : performance.now() * 1000;\r\n    return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, (c) => {\r\n        const r = (Math.random() * 16 + d) % 16 | 0;\r\n        return (c == 'x' ? r : (r & 0x3) | 0x8).toString(16);\r\n    });\r\n};\n\nvar mapIds = (values = [], keyName) => values.map((value) => (Object.assign({ [keyName]: (value && value[keyName]) || generateId() }, value)));\n\nvar isPrimitive = (value) => isNullOrUndefined(value) || !isObjectType(value);\n\nfunction deepEqual(object1, object2, isErrorObject) {\r\n    if (isPrimitive(object1) ||\r\n        isPrimitive(object2) ||\r\n        object1 instanceof Date ||\r\n        object2 instanceof Date) {\r\n        return object1 === object2;\r\n    }\r\n    if (!React.isValidElement(object1)) {\r\n        const keys1 = Object.keys(object1);\r\n        const keys2 = Object.keys(object2);\r\n        if (keys1.length !== keys2.length) {\r\n            return false;\r\n        }\r\n        for (const key of keys1) {\r\n            const val1 = object1[key];\r\n            if (!(isErrorObject && key === 'ref')) {\r\n                const val2 = object2[key];\r\n                if ((isObject(val1) || Array.isArray(val1)) &&\r\n                    (isObject(val2) || Array.isArray(val2))\r\n                    ? !deepEqual(val1, val2, isErrorObject)\r\n                    : val1 !== val2) {\r\n                    return false;\r\n                }\r\n            }\r\n        }\r\n    }\r\n    return true;\r\n}\n\nfunction deepMerge(target, source) {\r\n    if (isPrimitive(target) || isPrimitive(source)) {\r\n        return source;\r\n    }\r\n    for (const key in source) {\r\n        const targetValue = target[key];\r\n        const sourceValue = source[key];\r\n        try {\r\n            target[key] =\r\n                (isObject(targetValue) && isObject(sourceValue)) ||\r\n                    (Array.isArray(targetValue) && Array.isArray(sourceValue))\r\n                    ? deepMerge(targetValue, sourceValue)\r\n                    : sourceValue;\r\n        }\r\n        catch (_a) { }\r\n    }\r\n    return target;\r\n}\n\nfunction setDirtyFields(values, defaultValues, dirtyFields, parentNode, parentName) {\r\n    let index = -1;\r\n    while (++index < values.length) {\r\n        for (const key in values[index]) {\r\n            if (Array.isArray(values[index][key])) {\r\n                !dirtyFields[index] && (dirtyFields[index] = {});\r\n                dirtyFields[index][key] = [];\r\n                setDirtyFields(values[index][key], get(defaultValues[index] || {}, key, []), dirtyFields[index][key], dirtyFields[index], key);\r\n            }\r\n            else {\r\n                deepEqual(get(defaultValues[index] || {}, key), values[index][key])\r\n                    ? set(dirtyFields[index] || {}, key)\r\n                    : (dirtyFields[index] = Object.assign(Object.assign({}, dirtyFields[index]), { [key]: true }));\r\n            }\r\n        }\r\n        parentNode &&\r\n            !dirtyFields.length &&\r\n            delete parentNode[parentName];\r\n    }\r\n    return dirtyFields;\r\n}\r\nvar setFieldArrayDirtyFields = (values, defaultValues, dirtyFields) => deepMerge(setDirtyFields(values, defaultValues, dirtyFields.slice(0, values.length)), setDirtyFields(defaultValues, values, dirtyFields.slice(0, values.length)));\n\nfunction append(data, value) {\r\n    return [...data, ...convertToArrayPayload(value)];\r\n}\n\nvar fillEmptyArray = (value) => Array.isArray(value) ? Array(value.length).fill(undefined) : undefined;\n\nfunction insert(data, index, value) {\r\n    return [\r\n        ...data.slice(0, index),\r\n        ...convertToArrayPayload(value),\r\n        ...data.slice(index),\r\n    ];\r\n}\n\nvar isString = (value) => typeof value === 'string';\n\nvar moveArrayAt = (data, from, to) => {\r\n    if (Array.isArray(data)) {\r\n        if (isUndefined(data[to])) {\r\n            data[to] = undefined;\r\n        }\r\n        data.splice(to, 0, data.splice(from, 1)[0]);\r\n        return data;\r\n    }\r\n    return [];\r\n};\n\nfunction prepend(data, value) {\r\n    return [...convertToArrayPayload(value), ...data];\r\n}\n\nfunction removeAtIndexes(data, indexes) {\r\n    let i = 0;\r\n    const temp = [...data];\r\n    for (const index of indexes) {\r\n        temp.splice(index - i, 1);\r\n        i++;\r\n    }\r\n    return compact(temp).length ? temp : [];\r\n}\r\nvar removeArrayAt = (data, index) => isUndefined(index)\r\n    ? []\r\n    : removeAtIndexes(data, convertToArrayPayload(index).sort((a, b) => a - b));\n\nvar swapArrayAt = (data, indexA, indexB) => {\r\n    data[indexA] = [data[indexB], (data[indexB] = data[indexA])][0];\r\n};\n\nvar isBoolean = (value) => typeof value === 'boolean';\n\nfunction baseGet(object, updatePath) {\r\n    const length = updatePath.slice(0, -1).length;\r\n    let index = 0;\r\n    while (index < length) {\r\n        object = isUndefined(object) ? index++ : object[updatePath[index++]];\r\n    }\r\n    return object;\r\n}\r\nfunction unset(object, path) {\r\n    const updatePath = isKey(path) ? [path] : stringToPath(path);\r\n    const childObject = updatePath.length == 1 ? object : baseGet(object, updatePath);\r\n    const key = updatePath[updatePath.length - 1];\r\n    let previousObjRef;\r\n    if (childObject) {\r\n        delete childObject[key];\r\n    }\r\n    for (let k = 0; k < updatePath.slice(0, -1).length; k++) {\r\n        let index = -1;\r\n        let objectRef;\r\n        const currentPaths = updatePath.slice(0, -(k + 1));\r\n        const currentPathsLength = currentPaths.length - 1;\r\n        if (k > 0) {\r\n            previousObjRef = object;\r\n        }\r\n        while (++index < currentPaths.length) {\r\n            const item = currentPaths[index];\r\n            objectRef = objectRef ? objectRef[item] : object[item];\r\n            if (currentPathsLength === index &&\r\n                ((isObject(objectRef) && isEmptyObject(objectRef)) ||\r\n                    (Array.isArray(objectRef) &&\r\n                        !objectRef.filter((data) => (isObject(data) && !isEmptyObject(data)) || isBoolean(data)).length))) {\r\n                previousObjRef ? delete previousObjRef[item] : delete object[item];\r\n            }\r\n            previousObjRef = objectRef;\r\n        }\r\n    }\r\n    return object;\r\n}\n\nconst useFieldArray = ({ control, name, keyName = 'id', shouldUnregister, }) => {\r\n    const methods = useFormContext();\r\n    const focusNameRef = React.useRef('');\r\n    const isMountedRef = React.useRef(false);\r\n    const { isWatchAllRef, watchFieldsRef, getIsDirty, watchSubjectRef, fieldArraySubjectRef, fieldArrayNamesRef, fieldsRef, defaultValuesRef, formStateRef, formStateSubjectRef, readFormStateRef, validFieldsRef, fieldsWithValidationRef, fieldArrayDefaultValuesRef, unregister, shouldUnmount, inFieldArrayActionRef, } = control || methods.control;\r\n    const [fields, setFields] = React.useState(mapIds(get(fieldsRef.current, name) && isMountedRef.current\r\n        ? get(getFieldsValues(fieldsRef), name)\r\n        : get(fieldArrayDefaultValuesRef.current, getNodeParentName(name))\r\n            ? get(fieldArrayDefaultValuesRef.current, name, [])\r\n            : get(defaultValuesRef.current, name, []), keyName));\r\n    set(fieldArrayDefaultValuesRef.current, name, [...fields]);\r\n    fieldArrayNamesRef.current.add(name);\r\n    const omitKey = (fields) => fields.map((field) => omit((field || {}), keyName));\r\n    const getCurrentFieldsValues = () => {\r\n        const values = get(getFieldsValues(fieldsRef), name, []);\r\n        return mapIds(get(fieldArrayDefaultValuesRef.current, name, []).map((item, index) => (Object.assign(Object.assign({}, item), values[index]))), keyName);\r\n    };\r\n    const getFocusDetail = (index, options) => options\r\n        ? !isUndefined(options.focusIndex)\r\n            ? `${name}.${options.focusIndex}`\r\n            : options.focusName\r\n                ? options.focusName\r\n                : !options.shouldFocus\r\n                    ? ''\r\n                    : `${name}.${index}`\r\n        : `${name}.${index}`;\r\n    const resetFields = (index) => convertToArrayPayload(index).forEach((currentIndex) => set(fieldsRef.current, `${name}${isUndefined(currentIndex) ? '' : `.${currentIndex}`}`, isUndefined(currentIndex) ? [] : undefined));\r\n    const setFieldsAndNotify = (fieldsValues = []) => setFields(mapIds(fieldsValues, keyName));\r\n    const cleanup = (ref) => !compact(get(ref, name, [])).length && unset(ref, name);\r\n    const updateDirtyFieldsWithDefaultValues = (updatedFieldArrayValues) => updatedFieldArrayValues &&\r\n        set(formStateRef.current.dirtyFields, name, setFieldArrayDirtyFields(omitKey(updatedFieldArrayValues), get(defaultValuesRef.current, name, []), get(formStateRef.current.dirtyFields, name, [])));\r\n    const batchStateUpdate = (method, args, updatedFieldArrayValues = [], shouldSet = true) => {\r\n        inFieldArrayActionRef.current = true;\r\n        if (get(fieldsRef.current, name)) {\r\n            const output = method(get(fieldsRef.current, name), args.argA, args.argB);\r\n            shouldSet && set(fieldsRef.current, name, output);\r\n        }\r\n        if (Array.isArray(get(formStateRef.current.errors, name))) {\r\n            const output = method(get(formStateRef.current.errors, name), args.argA, args.argB);\r\n            shouldSet && set(formStateRef.current.errors, name, output);\r\n            cleanup(formStateRef.current.errors);\r\n        }\r\n        if (readFormStateRef.current.touchedFields &&\r\n            get(formStateRef.current.touchedFields, name)) {\r\n            const output = method(get(formStateRef.current.touchedFields, name), args.argA, args.argB);\r\n            shouldSet && set(formStateRef.current.touchedFields, name, output);\r\n            cleanup(formStateRef.current.touchedFields);\r\n        }\r\n        if (readFormStateRef.current.dirtyFields ||\r\n            readFormStateRef.current.isDirty) {\r\n            set(formStateRef.current.dirtyFields, name, setFieldArrayDirtyFields(omitKey(updatedFieldArrayValues), get(defaultValuesRef.current, name, []), get(formStateRef.current.dirtyFields, name, [])));\r\n            updateDirtyFieldsWithDefaultValues(updatedFieldArrayValues);\r\n            cleanup(formStateRef.current.dirtyFields);\r\n        }\r\n        if (readFormStateRef.current.isValid) {\r\n            set(validFieldsRef.current, name, method(get(validFieldsRef.current, name, []), args.argA));\r\n            cleanup(validFieldsRef.current);\r\n            set(fieldsWithValidationRef.current, name, method(get(fieldsWithValidationRef.current, name, []), args.argA));\r\n            cleanup(fieldsWithValidationRef.current);\r\n        }\r\n        formStateSubjectRef.current.next({\r\n            isDirty: getIsDirty(name, omitKey(updatedFieldArrayValues)),\r\n            errors: formStateRef.current.errors,\r\n            isValid: formStateRef.current.isValid,\r\n        });\r\n    };\r\n    const registerFieldArray = (values, index = 0, parentName = '') => values.forEach((appendValueItem, valueIndex) => !isPrimitive(appendValueItem) &&\r\n        Object.entries(appendValueItem).forEach(([key, value]) => {\r\n            const inputName = `${parentName || name}.${parentName ? valueIndex : index + valueIndex}.${key}`;\r\n            Array.isArray(value)\r\n                ? registerFieldArray(value, valueIndex, inputName)\r\n                : set(fieldsRef.current, inputName, {\r\n                    _f: {\r\n                        ref: {\r\n                            name: inputName,\r\n                        },\r\n                        name: inputName,\r\n                        value: isPrimitive(value) ? value : Object.assign({}, value),\r\n                    },\r\n                });\r\n        }));\r\n    const append$1 = (value, options) => {\r\n        const appendValue = convertToArrayPayload(value);\r\n        const updatedFieldArrayValues = append(getCurrentFieldsValues(), appendValue);\r\n        const currentIndex = updatedFieldArrayValues.length - appendValue.length;\r\n        setFieldsAndNotify(updatedFieldArrayValues);\r\n        batchStateUpdate(append, {\r\n            argA: fillEmptyArray(value),\r\n        }, updatedFieldArrayValues, false);\r\n        registerFieldArray(appendValue, currentIndex);\r\n        focusNameRef.current = getFocusDetail(currentIndex, options);\r\n    };\r\n    const prepend$1 = (value, options) => {\r\n        const prependValue = convertToArrayPayload(value);\r\n        const updatedFieldArrayValues = prepend(getCurrentFieldsValues(), prependValue);\r\n        setFieldsAndNotify(updatedFieldArrayValues);\r\n        batchStateUpdate(prepend, {\r\n            argA: fillEmptyArray(value),\r\n        }, updatedFieldArrayValues);\r\n        registerFieldArray(prependValue);\r\n        focusNameRef.current = getFocusDetail(0, options);\r\n    };\r\n    const remove = (index) => {\r\n        const updatedFieldArrayValues = removeArrayAt(getCurrentFieldsValues(), index);\r\n        resetFields(index);\r\n        setFieldsAndNotify(updatedFieldArrayValues);\r\n        batchStateUpdate(removeArrayAt, {\r\n            argA: index,\r\n        }, updatedFieldArrayValues);\r\n    };\r\n    const insert$1 = (index, value, options) => {\r\n        const insertValue = convertToArrayPayload(value);\r\n        const updatedFieldArrayValues = insert(getCurrentFieldsValues(), index, insertValue);\r\n        setFieldsAndNotify(updatedFieldArrayValues);\r\n        batchStateUpdate(insert, {\r\n            argA: index,\r\n            argB: fillEmptyArray(value),\r\n        }, updatedFieldArrayValues);\r\n        registerFieldArray(insertValue, index);\r\n        focusNameRef.current = getFocusDetail(index, options);\r\n    };\r\n    const swap = (indexA, indexB) => {\r\n        const fieldValues = getCurrentFieldsValues();\r\n        swapArrayAt(fieldValues, indexA, indexB);\r\n        batchStateUpdate(swapArrayAt, {\r\n            argA: indexA,\r\n            argB: indexB,\r\n        }, fieldValues, false);\r\n        setFieldsAndNotify(fieldValues);\r\n    };\r\n    const move = (from, to) => {\r\n        const fieldValues = getCurrentFieldsValues();\r\n        moveArrayAt(fieldValues, from, to);\r\n        setFieldsAndNotify(fieldValues);\r\n        batchStateUpdate(moveArrayAt, {\r\n            argA: from,\r\n            argB: to,\r\n        }, fieldValues, false);\r\n    };\r\n    React.useEffect(() => {\r\n        inFieldArrayActionRef.current = false;\r\n        if (isWatchAllRef.current) {\r\n            formStateSubjectRef.current.next({});\r\n        }\r\n        else {\r\n            for (const watchField of watchFieldsRef.current) {\r\n                if (name.startsWith(watchField)) {\r\n                    formStateSubjectRef.current.next({});\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n        watchSubjectRef.current.next({\r\n            name,\r\n            formValues: getFieldsValues(fieldsRef),\r\n        });\r\n        focusNameRef.current &&\r\n            focusFieldBy(fieldsRef.current, (key) => isString(key) && key.startsWith(focusNameRef.current));\r\n        focusNameRef.current = '';\r\n        fieldArraySubjectRef.current.next({\r\n            name,\r\n            fields: omitKey([...fields]),\r\n        });\r\n    }, [fields, name]);\r\n    React.useEffect(() => {\r\n        const fieldArraySubscription = fieldArraySubjectRef.current.subscribe({\r\n            next({ name: inputFieldArrayName, fields, isReset }) {\r\n                if (isReset) {\r\n                    unset(fieldsRef.current, inputFieldArrayName || name);\r\n                    inputFieldArrayName\r\n                        ? set(fieldArrayDefaultValuesRef.current, inputFieldArrayName, fields)\r\n                        : (fieldArrayDefaultValuesRef.current = fields);\r\n                    setFieldsAndNotify(get(fieldArrayDefaultValuesRef.current, name));\r\n                }\r\n            },\r\n        });\r\n        !get(fieldsRef.current, name) && set(fieldsRef.current, name, []);\r\n        isMountedRef.current = true;\r\n        return () => {\r\n            fieldArraySubscription.unsubscribe();\r\n            (shouldUnmount || shouldUnregister) &&\r\n                unregister(name);\r\n        };\r\n    }, []);\r\n    return {\r\n        swap: React.useCallback(swap, [name]),\r\n        move: React.useCallback(move, [name]),\r\n        prepend: React.useCallback(prepend$1, [name]),\r\n        append: React.useCallback(append$1, [name]),\r\n        remove: React.useCallback(remove, [name]),\r\n        insert: React.useCallback(insert$1, [name]),\r\n        fields: fields,\r\n    };\r\n};\n\nfunction getFields(fieldsNames, fieldsRefs) {\r\n    const currentFields = {};\r\n    for (const name of fieldsNames) {\r\n        const field = get(fieldsRefs, name);\r\n        if (field) {\r\n            !isKey(name)\r\n                ? set(currentFields, name, field._f)\r\n                : (currentFields[name] = field._f);\r\n        }\r\n    }\r\n    return currentFields;\r\n}\n\nvar isFileInput = (element) => element.type === 'file';\n\nvar isMultipleSelect = (element) => element.type === `select-multiple`;\n\nvar isRadioInput = (element) => element.type === 'radio';\n\nconst defaultResult = {\r\n    value: false,\r\n    isValid: false,\r\n};\r\nconst validResult = { value: true, isValid: true };\r\nvar getCheckboxValue = (options) => {\r\n    if (Array.isArray(options)) {\r\n        if (options.length > 1) {\r\n            const values = options\r\n                .filter((option) => option && option.checked && !option.disabled)\r\n                .map((option) => option.value);\r\n            return { value: values, isValid: !!values.length };\r\n        }\r\n        return options[0].checked && !options[0].disabled\r\n            ? // @ts-expect-error expected to work in the browser\r\n                options[0].attributes && !isUndefined(options[0].attributes.value)\r\n                    ? isUndefined(options[0].value) || options[0].value === ''\r\n                        ? validResult\r\n                        : { value: options[0].value, isValid: true }\r\n                    : validResult\r\n            : defaultResult;\r\n    }\r\n    return defaultResult;\r\n};\n\nvar getFieldValueAs = (value, { valueAsNumber, valueAsDate, setValueAs }) => isUndefined(value)\r\n    ? value\r\n    : valueAsNumber\r\n        ? value === ''\r\n            ? NaN\r\n            : +value\r\n        : valueAsDate\r\n            ? new Date(value)\r\n            : setValueAs\r\n                ? setValueAs(value)\r\n                : value;\n\nvar getMultipleSelectValue = (options) => [...options]\r\n    .filter(({ selected }) => selected)\r\n    .map(({ value }) => value);\n\nconst defaultReturn = {\r\n    isValid: false,\r\n    value: null,\r\n};\r\nvar getRadioValue = (options) => Array.isArray(options)\r\n    ? options.reduce((previous, option) => option && option.checked && !option.disabled\r\n        ? {\r\n            isValid: true,\r\n            value: option.value,\r\n        }\r\n        : previous, defaultReturn)\r\n    : defaultReturn;\n\nfunction getFieldValue(field) {\r\n    if (field && field._f) {\r\n        const ref = field._f.ref;\r\n        if (ref.disabled) {\r\n            return;\r\n        }\r\n        if (isFileInput(ref)) {\r\n            return ref.files;\r\n        }\r\n        if (isRadioInput(ref)) {\r\n            return getRadioValue(field._f.refs).value;\r\n        }\r\n        if (isMultipleSelect(ref)) {\r\n            return getMultipleSelectValue(ref.options);\r\n        }\r\n        if (isCheckBoxInput(ref)) {\r\n            return getCheckboxValue(field._f.refs).value;\r\n        }\r\n        return getFieldValueAs(isUndefined(ref.value) ? field._f.ref.value : ref.value, field._f);\r\n    }\r\n}\n\nvar hasValidation = (options, mounted) => mounted &&\r\n    options &&\r\n    (options.required ||\r\n        options.min ||\r\n        options.max ||\r\n        options.maxLength ||\r\n        options.minLength ||\r\n        options.pattern ||\r\n        options.validate);\n\nvar skipValidation = ({ isOnBlur, isOnChange, isOnTouch, isTouched, isReValidateOnBlur, isReValidateOnChange, isBlurEvent, isSubmitted, isOnAll, }) => {\r\n    if (isOnAll) {\r\n        return false;\r\n    }\r\n    else if (!isSubmitted && isOnTouch) {\r\n        return !(isTouched || isBlurEvent);\r\n    }\r\n    else if (isSubmitted ? isReValidateOnBlur : isOnBlur) {\r\n        return !isBlurEvent;\r\n    }\r\n    else if (isSubmitted ? isReValidateOnChange : isOnChange) {\r\n        return isBlurEvent;\r\n    }\r\n    return true;\r\n};\n\nvar isFunction = (value) => typeof value === 'function';\n\nvar isMessage = (value) => isString(value) || React.isValidElement(value);\n\nvar isRegex = (value) => value instanceof RegExp;\n\nfunction getValidateError(result, ref, type = 'validate') {\r\n    if (isMessage(result) ||\r\n        (Array.isArray(result) && result.every(isMessage)) ||\r\n        (isBoolean(result) && !result)) {\r\n        return {\r\n            type,\r\n            message: isMessage(result) ? result : '',\r\n            ref,\r\n        };\r\n    }\r\n}\n\nvar getValueAndMessage = (validationData) => isObject(validationData) && !isRegex(validationData)\r\n    ? validationData\r\n    : {\r\n        value: validationData,\r\n        message: '',\r\n    };\n\nvar validateField = async ({ _f: { ref, refs, required, maxLength, minLength, min, max, pattern, validate, name, value: inputValue, valueAsNumber, mount, }, }, validateAllFieldCriteria) => {\r\n    if (!mount) {\r\n        return {};\r\n    }\r\n    const error = {};\r\n    const isRadio = isRadioInput(ref);\r\n    const isCheckBox = isCheckBoxInput(ref);\r\n    const isRadioOrCheckbox = isRadio || isCheckBox;\r\n    const isEmpty = ((valueAsNumber || isFileInput(ref)) && !ref.value) ||\r\n        inputValue === '' ||\r\n        (Array.isArray(inputValue) && !inputValue.length);\r\n    const appendErrorsCurry = appendErrors.bind(null, name, validateAllFieldCriteria, error);\r\n    const getMinMaxMessage = (exceedMax, maxLengthMessage, minLengthMessage, maxType = INPUT_VALIDATION_RULES.maxLength, minType = INPUT_VALIDATION_RULES.minLength) => {\r\n        const message = exceedMax ? maxLengthMessage : minLengthMessage;\r\n        error[name] = Object.assign({ type: exceedMax ? maxType : minType, message,\r\n            ref }, appendErrorsCurry(exceedMax ? maxType : minType, message));\r\n    };\r\n    if (required &&\r\n        ((!isRadio && !isCheckBox && (isEmpty || isNullOrUndefined(inputValue))) ||\r\n            (isBoolean(inputValue) && !inputValue) ||\r\n            (isCheckBox && !getCheckboxValue(refs).isValid) ||\r\n            (isRadio && !getRadioValue(refs).isValid))) {\r\n        const { value, message } = isMessage(required)\r\n            ? { value: !!required, message: required }\r\n            : getValueAndMessage(required);\r\n        if (value) {\r\n            error[name] = Object.assign({ type: INPUT_VALIDATION_RULES.required, message, ref: isRadioOrCheckbox ? (refs || [])[0] || {} : ref }, appendErrorsCurry(INPUT_VALIDATION_RULES.required, message));\r\n            if (!validateAllFieldCriteria) {\r\n                return error;\r\n            }\r\n        }\r\n    }\r\n    if ((!isNullOrUndefined(min) || !isNullOrUndefined(max)) &&\r\n        inputValue !== '') {\r\n        let exceedMax;\r\n        let exceedMin;\r\n        const maxOutput = getValueAndMessage(max);\r\n        const minOutput = getValueAndMessage(min);\r\n        if (!isNaN(inputValue)) {\r\n            const valueNumber = ref.valueAsNumber || parseFloat(inputValue);\r\n            if (!isNullOrUndefined(maxOutput.value)) {\r\n                exceedMax = valueNumber > maxOutput.value;\r\n            }\r\n            if (!isNullOrUndefined(minOutput.value)) {\r\n                exceedMin = valueNumber < minOutput.value;\r\n            }\r\n        }\r\n        else {\r\n            const valueDate = ref.valueAsDate || new Date(inputValue);\r\n            if (isString(maxOutput.value)) {\r\n                exceedMax = valueDate > new Date(maxOutput.value);\r\n            }\r\n            if (isString(minOutput.value)) {\r\n                exceedMin = valueDate < new Date(minOutput.value);\r\n            }\r\n        }\r\n        if (exceedMax || exceedMin) {\r\n            getMinMaxMessage(!!exceedMax, maxOutput.message, minOutput.message, INPUT_VALIDATION_RULES.max, INPUT_VALIDATION_RULES.min);\r\n            if (!validateAllFieldCriteria) {\r\n                return error;\r\n            }\r\n        }\r\n    }\r\n    if (isString(inputValue) && !isEmpty && (maxLength || minLength)) {\r\n        const maxLengthOutput = getValueAndMessage(maxLength);\r\n        const minLengthOutput = getValueAndMessage(minLength);\r\n        const exceedMax = !isNullOrUndefined(maxLengthOutput.value) &&\r\n            inputValue.length > maxLengthOutput.value;\r\n        const exceedMin = !isNullOrUndefined(minLengthOutput.value) &&\r\n            inputValue.length < minLengthOutput.value;\r\n        if (exceedMax || exceedMin) {\r\n            getMinMaxMessage(exceedMax, maxLengthOutput.message, minLengthOutput.message);\r\n            if (!validateAllFieldCriteria) {\r\n                return error;\r\n            }\r\n        }\r\n    }\r\n    if (isString(inputValue) && pattern && !isEmpty) {\r\n        const { value: patternValue, message } = getValueAndMessage(pattern);\r\n        if (isRegex(patternValue) && !inputValue.match(patternValue)) {\r\n            error[name] = Object.assign({ type: INPUT_VALIDATION_RULES.pattern, message,\r\n                ref }, appendErrorsCurry(INPUT_VALIDATION_RULES.pattern, message));\r\n            if (!validateAllFieldCriteria) {\r\n                return error;\r\n            }\r\n        }\r\n    }\r\n    if (validate) {\r\n        const validateRef = isRadioOrCheckbox && refs ? refs[0] : ref;\r\n        if (isFunction(validate)) {\r\n            const result = await validate(inputValue);\r\n            const validateError = getValidateError(result, validateRef);\r\n            if (validateError) {\r\n                error[name] = Object.assign(Object.assign({}, validateError), appendErrorsCurry(INPUT_VALIDATION_RULES.validate, validateError.message));\r\n                if (!validateAllFieldCriteria) {\r\n                    return error;\r\n                }\r\n            }\r\n        }\r\n        else if (isObject(validate)) {\r\n            let validationResult = {};\r\n            for (const [key, validateFunction] of Object.entries(validate)) {\r\n                if (!isEmptyObject(validationResult) && !validateAllFieldCriteria) {\r\n                    break;\r\n                }\r\n                const validateResult = await validateFunction(inputValue);\r\n                const validateError = getValidateError(validateResult, validateRef, key);\r\n                if (validateError) {\r\n                    validationResult = Object.assign(Object.assign({}, validateError), appendErrorsCurry(key, validateError.message));\r\n                    if (validateAllFieldCriteria) {\r\n                        error[name] = validationResult;\r\n                    }\r\n                }\r\n            }\r\n            if (!isEmptyObject(validationResult)) {\r\n                error[name] = Object.assign({ ref: validateRef }, validationResult);\r\n                if (!validateAllFieldCriteria) {\r\n                    return error;\r\n                }\r\n            }\r\n        }\r\n    }\r\n    return error;\r\n};\n\nvar getValidationModes = (mode) => ({\r\n    isOnSubmit: !mode || mode === VALIDATION_MODE.onSubmit,\r\n    isOnBlur: mode === VALIDATION_MODE.onBlur,\r\n    isOnChange: mode === VALIDATION_MODE.onChange,\r\n    isOnAll: mode === VALIDATION_MODE.all,\r\n    isOnTouch: mode === VALIDATION_MODE.onTouched,\r\n});\n\nvar isHTMLElement = (value) => value instanceof HTMLElement;\n\nvar isRadioOrCheckboxFunction = (ref) => isRadioInput(ref) || isCheckBoxInput(ref);\n\nclass Subscription {\r\n    constructor() {\r\n        this.tearDowns = [];\r\n    }\r\n    add(tearDown) {\r\n        this.tearDowns.push(tearDown);\r\n    }\r\n    unsubscribe() {\r\n        for (const teardown of this.tearDowns) {\r\n            teardown();\r\n        }\r\n        this.tearDowns = [];\r\n    }\r\n}\r\nclass Subscriber {\r\n    constructor(observer, subscription) {\r\n        this.observer = observer;\r\n        this.closed = false;\r\n        subscription.add(() => (this.closed = true));\r\n    }\r\n    next(value) {\r\n        if (!this.closed) {\r\n            this.observer.next(value);\r\n        }\r\n    }\r\n}\r\nclass Subject {\r\n    constructor() {\r\n        this.observers = [];\r\n    }\r\n    next(value) {\r\n        for (const observer of this.observers) {\r\n            observer.next(value);\r\n        }\r\n    }\r\n    subscribe(observer) {\r\n        const subscription = new Subscription();\r\n        const subscriber = new Subscriber(observer, subscription);\r\n        this.observers.push(subscriber);\r\n        return subscription;\r\n    }\r\n    unsubscribe() {\r\n        this.observers = [];\r\n    }\r\n}\n\nconst isWindowUndefined = typeof window === 'undefined';\r\nfunction useForm({ mode = VALIDATION_MODE.onSubmit, reValidateMode = VALIDATION_MODE.onChange, resolver, context, defaultValues = {}, shouldFocusError = true, shouldUnregister, criteriaMode, } = {}) {\r\n    const fieldsRef = React.useRef({});\r\n    const fieldsNamesRef = React.useRef(new Set());\r\n    const formStateSubjectRef = React.useRef(new Subject());\r\n    const unregisterFieldsNamesRef = React.useRef(new Set());\r\n    const watchSubjectRef = React.useRef(new Subject());\r\n    const controllerSubjectRef = React.useRef(new Subject());\r\n    const fieldArraySubjectRef = React.useRef(new Subject());\r\n    const fieldArrayDefaultValuesRef = React.useRef({});\r\n    const inFieldArrayActionRef = React.useRef(false);\r\n    const watchFieldsRef = React.useRef(new Set());\r\n    const isMountedRef = React.useRef(false);\r\n    const fieldsWithValidationRef = React.useRef({});\r\n    const validFieldsRef = React.useRef({});\r\n    const defaultValuesRef = React.useRef(defaultValues);\r\n    const isWatchAllRef = React.useRef(false);\r\n    const contextRef = React.useRef(context);\r\n    const resolverRef = React.useRef(resolver);\r\n    const fieldArrayNamesRef = React.useRef(new Set());\r\n    const validationMode = getValidationModes(mode);\r\n    const isValidateAllFieldCriteria = criteriaMode === VALIDATION_MODE.all;\r\n    const [formState, updateFormState] = React.useState({\r\n        isDirty: false,\r\n        isValidating: false,\r\n        dirtyFields: {},\r\n        isSubmitted: false,\r\n        submitCount: 0,\r\n        touchedFields: {},\r\n        isSubmitting: false,\r\n        isSubmitSuccessful: false,\r\n        isValid: !validationMode.isOnSubmit,\r\n        errors: {},\r\n    });\r\n    const readFormStateRef = React.useRef({\r\n        isDirty: !isProxyEnabled,\r\n        dirtyFields: !isProxyEnabled,\r\n        touchedFields: !isProxyEnabled,\r\n        isValidating: !isProxyEnabled,\r\n        isValid: !isProxyEnabled,\r\n        errors: !isProxyEnabled,\r\n    });\r\n    const formStateRef = React.useRef(formState);\r\n    contextRef.current = context;\r\n    resolverRef.current = resolver;\r\n    const getIsValid = () => {\r\n        formStateRef.current.isValid =\r\n            deepEqual(validFieldsRef.current, fieldsWithValidationRef.current) &&\r\n                isEmptyObject(formStateRef.current.errors);\r\n        return formStateRef.current.isValid;\r\n    };\r\n    const shouldRenderBaseOnError = React.useCallback((name, error, shouldRender = false, state = {}, isValid, isWatched) => {\r\n        const previousError = get(formStateRef.current.errors, name);\r\n        if (error) {\r\n            unset(validFieldsRef.current, name);\r\n            set(formStateRef.current.errors, name, error);\r\n        }\r\n        else {\r\n            (get(fieldsWithValidationRef.current, name) || resolverRef.current) &&\r\n                set(validFieldsRef.current, name, true);\r\n            unset(formStateRef.current.errors, name);\r\n        }\r\n        if ((shouldRender ||\r\n            isWatched ||\r\n            (error ? !deepEqual(previousError, error, true) : previousError) ||\r\n            !isEmptyObject(state) ||\r\n            (readFormStateRef.current.isValid &&\r\n                formStateRef.current.isValid !==\r\n                    (resolverRef.current ? !!isValid : getIsValid()))) &&\r\n            !isNullOrUndefined(shouldRender)) {\r\n            const updatedFormState = Object.assign(Object.assign({}, state), { isValid: resolverRef.current ? !!isValid : getIsValid(), errors: formStateRef.current.errors, name });\r\n            formStateRef.current = Object.assign(Object.assign({}, formStateRef.current), updatedFormState);\r\n            formStateSubjectRef.current.next(isWatched ? { name } : updatedFormState);\r\n        }\r\n        formStateSubjectRef.current.next({\r\n            isValidating: false,\r\n        });\r\n    }, []);\r\n    const setFieldValue = React.useCallback((name, rawValue, options = {}, shouldRender, shouldRegister) => {\r\n        shouldRegister && register(name);\r\n        const field = get(fieldsRef.current, name);\r\n        if (field) {\r\n            const _f = field._f;\r\n            if (_f) {\r\n                const value = isWeb && isHTMLElement(_f.ref) && isNullOrUndefined(rawValue)\r\n                    ? ''\r\n                    : rawValue;\r\n                _f.value = getFieldValueAs(rawValue, _f);\r\n                if (isRadioInput(_f.ref)) {\r\n                    (_f.refs || []).forEach((radioRef) => (radioRef.checked = radioRef.value === value));\r\n                }\r\n                else if (isFileInput(_f.ref) && !isString(value)) {\r\n                    _f.ref.files = value;\r\n                }\r\n                else if (isMultipleSelect(_f.ref)) {\r\n                    [..._f.ref.options].forEach((selectRef) => (selectRef.selected = value.includes(selectRef.value)));\r\n                }\r\n                else if (isCheckBoxInput(_f.ref) && _f.refs) {\r\n                    _f.refs.length > 1\r\n                        ? _f.refs.forEach((checkboxRef) => (checkboxRef.checked = Array.isArray(value)\r\n                            ? !!value.find((data) => data === checkboxRef.value)\r\n                            : value === checkboxRef.value))\r\n                        : (_f.refs[0].checked = !!value);\r\n                }\r\n                else {\r\n                    _f.ref.value = value;\r\n                }\r\n                if (shouldRender) {\r\n                    const values = getFieldsValues(fieldsRef);\r\n                    set(values, name, rawValue);\r\n                    controllerSubjectRef.current.next({\r\n                        values: Object.assign(Object.assign({}, defaultValuesRef.current), values),\r\n                        name,\r\n                    });\r\n                }\r\n                options.shouldDirty && updateAndGetDirtyState(name, value);\r\n                options.shouldValidate && trigger(name);\r\n            }\r\n            else {\r\n                field._f = {\r\n                    ref: {\r\n                        name,\r\n                        value: rawValue,\r\n                    },\r\n                    value: rawValue,\r\n                };\r\n            }\r\n        }\r\n    }, []);\r\n    const getIsDirty = React.useCallback((name, data) => {\r\n        const formValues = getFieldsValues(fieldsRef);\r\n        name && data && set(formValues, name, data);\r\n        return !deepEqual(formValues, defaultValuesRef.current);\r\n    }, []);\r\n    const updateAndGetDirtyState = React.useCallback((name, inputValue, shouldRender = true) => {\r\n        if (readFormStateRef.current.isDirty ||\r\n            readFormStateRef.current.dirtyFields) {\r\n            const isFieldDirty = !deepEqual(get(defaultValuesRef.current, name), inputValue);\r\n            const isDirtyFieldExist = get(formStateRef.current.dirtyFields, name);\r\n            const previousIsDirty = formStateRef.current.isDirty;\r\n            isFieldDirty\r\n                ? set(formStateRef.current.dirtyFields, name, true)\r\n                : unset(formStateRef.current.dirtyFields, name);\r\n            formStateRef.current.isDirty = getIsDirty();\r\n            const state = {\r\n                isDirty: formStateRef.current.isDirty,\r\n                dirtyFields: formStateRef.current.dirtyFields,\r\n                name,\r\n            };\r\n            const isChanged = (readFormStateRef.current.isDirty &&\r\n                previousIsDirty !== state.isDirty) ||\r\n                (readFormStateRef.current.dirtyFields &&\r\n                    isDirtyFieldExist !== get(formStateRef.current.dirtyFields, name));\r\n            isChanged && shouldRender && formStateSubjectRef.current.next(state);\r\n            return isChanged ? state : {};\r\n        }\r\n        return {};\r\n    }, []);\r\n    const executeValidation = React.useCallback(async (name, skipReRender) => {\r\n        const error = (await validateField(get(fieldsRef.current, name), isValidateAllFieldCriteria))[name];\r\n        shouldRenderBaseOnError(name, error, skipReRender);\r\n        return isUndefined(error);\r\n    }, [isValidateAllFieldCriteria]);\r\n    const executeSchemaOrResolverValidation = React.useCallback(async (names, currentNames = []) => {\r\n        const { errors } = await resolverRef.current(getFieldsValues(fieldsRef), contextRef.current, {\r\n            criteriaMode,\r\n            names: currentNames,\r\n            fields: getFields(fieldsNamesRef.current, fieldsRef.current),\r\n        });\r\n        for (const name of names) {\r\n            const error = get(errors, name);\r\n            error\r\n                ? set(formStateRef.current.errors, name, error)\r\n                : unset(formStateRef.current.errors, name);\r\n        }\r\n        return errors;\r\n    }, [criteriaMode]);\r\n    const validateForm = async (fieldsRef) => {\r\n        for (const name in fieldsRef) {\r\n            const field = fieldsRef[name];\r\n            if (field) {\r\n                const _f = field._f;\r\n                const current = omit(field, '_f');\r\n                if (_f) {\r\n                    const fieldError = await validateField(field, isValidateAllFieldCriteria);\r\n                    if (fieldError[_f.name]) {\r\n                        set(formStateRef.current.errors, _f.name, fieldError[_f.name]);\r\n                        unset(validFieldsRef.current, _f.name);\r\n                    }\r\n                    else if (get(fieldsWithValidationRef.current, _f.name)) {\r\n                        set(validFieldsRef.current, _f.name, true);\r\n                        unset(formStateRef.current.errors, _f.name);\r\n                    }\r\n                }\r\n                current && (await validateForm(current));\r\n            }\r\n        }\r\n    };\r\n    const trigger = React.useCallback(async (name, options = {}) => {\r\n        const fieldNames = isUndefined(name)\r\n            ? Object.keys(fieldsRef.current)\r\n            : convertToArrayPayload(name);\r\n        let isValid;\r\n        let schemaResult = {};\r\n        formStateSubjectRef.current.next({\r\n            isValidating: true,\r\n        });\r\n        if (resolverRef.current) {\r\n            schemaResult = await executeSchemaOrResolverValidation(fieldNames, isUndefined(name)\r\n                ? undefined\r\n                : fieldNames);\r\n            isValid = fieldNames.every((name) => !get(schemaResult, name));\r\n        }\r\n        else {\r\n            if (isUndefined(name)) {\r\n                await validateForm(fieldsRef.current);\r\n                isValid = isEmptyObject(formStateRef.current.errors);\r\n            }\r\n            else {\r\n                isValid = (await Promise.all(fieldNames\r\n                    .filter((fieldName) => get(fieldsRef.current, fieldName))\r\n                    .map(async (fieldName) => await executeValidation(fieldName, null)))).every(Boolean);\r\n            }\r\n        }\r\n        formStateSubjectRef.current.next(Object.assign(Object.assign({}, (isString(name) ? { name } : {})), { errors: formStateRef.current.errors, isValidating: false, isValid: resolverRef.current\r\n                ? isEmptyObject(schemaResult)\r\n                : getIsValid() }));\r\n        if (!isValid && options.shouldFocus) {\r\n            focusFieldBy(fieldsRef.current, (key) => get(formStateRef.current.errors, key), fieldNames);\r\n        }\r\n        return isValid;\r\n    }, [executeSchemaOrResolverValidation, executeValidation]);\r\n    const setInternalValues = React.useCallback((name, value, options) => Object.entries(value).forEach(([inputKey, inputValue]) => {\r\n        const fieldName = `${name}.${inputKey}`;\r\n        const field = get(fieldsRef.current, fieldName);\r\n        const isFieldArray = fieldArrayNamesRef.current.has(name);\r\n        isFieldArray || !isPrimitive(inputValue) || (field && !field._f)\r\n            ? setInternalValues(fieldName, inputValue, options)\r\n            : setFieldValue(fieldName, inputValue, options, true, !field);\r\n    }), [trigger]);\r\n    const isFieldWatched = (name) => isWatchAllRef.current ||\r\n        watchFieldsRef.current.has(name) ||\r\n        watchFieldsRef.current.has((name.match(/\\w+/) || [])[0]);\r\n    const updateValidAndValue = (name, options, ref, isWithinRefCallback) => {\r\n        const field = get(fieldsRef.current, name);\r\n        const defaultValue = isUndefined(field._f.value)\r\n            ? get(defaultValuesRef.current, name)\r\n            : field._f.value;\r\n        if (field && !isUndefined(defaultValue)) {\r\n            if (ref && ref.defaultChecked) {\r\n                field._f.value = getFieldValue(field);\r\n            }\r\n            else if (!isNameInFieldArray(fieldArrayNamesRef.current, name)) {\r\n                setFieldValue(name, defaultValue);\r\n            }\r\n            else {\r\n                field._f.value = defaultValue;\r\n            }\r\n        }\r\n        else {\r\n            field._f.value = getFieldValue(field);\r\n        }\r\n        if ((!isUndefined(defaultValue) || isWithinRefCallback) &&\r\n            hasValidation(options, field._f.mount) &&\r\n            !validationMode.isOnSubmit &&\r\n            field &&\r\n            readFormStateRef.current.isValid) {\r\n            validateField(field, isValidateAllFieldCriteria).then((error) => {\r\n                isEmptyObject(error)\r\n                    ? set(validFieldsRef.current, name, true)\r\n                    : unset(validFieldsRef.current, name);\r\n                formStateRef.current.isValid !== getIsValid() &&\r\n                    updateFormState(Object.assign(Object.assign({}, formStateRef.current), { isValid: getIsValid() }));\r\n            });\r\n        }\r\n        return defaultValue;\r\n    };\r\n    const setValue = (name, value, options = {}) => {\r\n        const field = get(fieldsRef.current, name);\r\n        const isFieldArray = fieldArrayNamesRef.current.has(name);\r\n        if (isFieldArray) {\r\n            fieldArraySubjectRef.current.next({\r\n                fields: value,\r\n                name,\r\n                isReset: true,\r\n            });\r\n            if ((readFormStateRef.current.isDirty ||\r\n                readFormStateRef.current.dirtyFields) &&\r\n                options.shouldDirty) {\r\n                set(formStateRef.current.dirtyFields, name, setFieldArrayDirtyFields(value, get(defaultValuesRef.current, name, []), get(formStateRef.current.dirtyFields, name, [])));\r\n                formStateSubjectRef.current.next({\r\n                    name,\r\n                    dirtyFields: formStateRef.current.dirtyFields,\r\n                    isDirty: getIsDirty(name, value),\r\n                });\r\n            }\r\n            !value.length &&\r\n                set(fieldsRef.current, name, []) &&\r\n                set(fieldArrayDefaultValuesRef.current, name, []);\r\n        }\r\n        ((field && !field._f) || isFieldArray) && !isNullOrUndefined(value)\r\n            ? setInternalValues(name, value, isFieldArray ? {} : options)\r\n            : setFieldValue(name, value, options, true, !field);\r\n        isFieldWatched(name) && formStateSubjectRef.current.next({});\r\n        watchSubjectRef.current.next({ name, formValues: getValues() });\r\n    };\r\n    const handleChange = React.useCallback(async ({ type, target, target: { value, type: inputType } }) => {\r\n        let name = target.name;\r\n        let error;\r\n        let isValid;\r\n        const field = get(fieldsRef.current, name);\r\n        if (field) {\r\n            let inputValue = inputType ? getFieldValue(field) : undefined;\r\n            inputValue = isUndefined(inputValue) ? value : inputValue;\r\n            const isBlurEvent = type === EVENTS.BLUR;\r\n            const { isOnBlur: isReValidateOnBlur, isOnChange: isReValidateOnChange, } = getValidationModes(reValidateMode);\r\n            const shouldSkipValidation = (!hasValidation(field._f, field._f.mount) &&\r\n                !resolverRef.current &&\r\n                !get(formStateRef.current.errors, name)) ||\r\n                skipValidation(Object.assign({ isBlurEvent, isTouched: !!get(formStateRef.current.touchedFields, name), isSubmitted: formStateRef.current.isSubmitted, isReValidateOnBlur,\r\n                    isReValidateOnChange }, validationMode));\r\n            const isWatched = !isBlurEvent && isFieldWatched(name);\r\n            if (!isUndefined(inputValue)) {\r\n                field._f.value = inputValue;\r\n            }\r\n            const state = updateAndGetDirtyState(name, field._f.value, false);\r\n            if (isBlurEvent && !get(formStateRef.current.touchedFields, name)) {\r\n                set(formStateRef.current.touchedFields, name, true);\r\n                readFormStateRef.current.touchedFields &&\r\n                    (state.touchedFields = formStateRef.current.touchedFields);\r\n            }\r\n            let shouldRender = !isEmptyObject(state) || isWatched;\r\n            if (shouldSkipValidation) {\r\n                !isBlurEvent &&\r\n                    watchSubjectRef.current.next({\r\n                        name,\r\n                        type,\r\n                        formValues: getValues(),\r\n                    });\r\n                return (shouldRender &&\r\n                    formStateSubjectRef.current.next(isWatched ? { name } : Object.assign(Object.assign({}, state), { name })));\r\n            }\r\n            formStateSubjectRef.current.next({\r\n                isValidating: true,\r\n            });\r\n            if (resolverRef.current) {\r\n                const { errors } = await resolverRef.current(getFieldsValues(fieldsRef), contextRef.current, {\r\n                    criteriaMode,\r\n                    fields: getFields([name], fieldsRef.current),\r\n                    names: [name],\r\n                });\r\n                const previousFormIsValid = formStateRef.current.isValid;\r\n                error = get(errors, name);\r\n                if (isCheckBoxInput(target) && !error) {\r\n                    const parentNodeName = getNodeParentName(name);\r\n                    const currentError = get(errors, parentNodeName, {});\r\n                    currentError.type && currentError.message && (error = currentError);\r\n                    if (currentError ||\r\n                        get(formStateRef.current.errors, parentNodeName)) {\r\n                        name = parentNodeName;\r\n                    }\r\n                }\r\n                isValid = isEmptyObject(errors);\r\n                previousFormIsValid !== isValid && (shouldRender = true);\r\n            }\r\n            else {\r\n                error = (await validateField(field, isValidateAllFieldCriteria))[name];\r\n            }\r\n            !isBlurEvent &&\r\n                watchSubjectRef.current.next({\r\n                    name,\r\n                    type,\r\n                    formValues: getValues(),\r\n                });\r\n            shouldRenderBaseOnError(name, error, shouldRender, state, isValid, isWatched);\r\n        }\r\n    }, []);\r\n    const getValues = (fieldNames) => {\r\n        const values = Object.assign(Object.assign({}, defaultValuesRef.current), getFieldsValues(fieldsRef));\r\n        return isUndefined(fieldNames)\r\n            ? values\r\n            : isString(fieldNames)\r\n                ? get(values, fieldNames)\r\n                : fieldNames.map((name) => get(values, name));\r\n    };\r\n    const updateIsValid = React.useCallback(async (values = {}) => {\r\n        const previousIsValid = formStateRef.current.isValid;\r\n        if (resolver) {\r\n            const { errors } = await resolverRef.current(Object.assign(Object.assign({}, getFieldsValues(fieldsRef)), values), contextRef.current, {\r\n                criteriaMode,\r\n                fields: getFields(fieldsNamesRef.current, fieldsRef.current),\r\n            });\r\n            formStateRef.current.isValid = isEmptyObject(errors);\r\n        }\r\n        else {\r\n            getIsValid();\r\n        }\r\n        previousIsValid !== formStateRef.current.isValid &&\r\n            formStateSubjectRef.current.next({\r\n                isValid: formStateRef.current.isValid,\r\n            });\r\n    }, [criteriaMode]);\r\n    const clearErrors = (name) => {\r\n        name\r\n            ? convertToArrayPayload(name).forEach((inputName) => unset(formStateRef.current.errors, inputName))\r\n            : (formStateRef.current.errors = {});\r\n        formStateSubjectRef.current.next({\r\n            errors: formStateRef.current.errors,\r\n        });\r\n    };\r\n    const setError = (name, error, options) => {\r\n        const ref = ((get(fieldsRef.current, name) || { _f: {} })._f || {}).ref;\r\n        set(formStateRef.current.errors, name, Object.assign(Object.assign({}, error), { ref }));\r\n        formStateSubjectRef.current.next({\r\n            name,\r\n            errors: formStateRef.current.errors,\r\n            isValid: false,\r\n        });\r\n        options && options.shouldFocus && ref && ref.focus && ref.focus();\r\n    };\r\n    const watchInternal = React.useCallback((fieldNames, defaultValue, isGlobal, formValues) => {\r\n        const isArrayNames = Array.isArray(fieldNames);\r\n        const fieldValues = formValues || isMountedRef.current\r\n            ? Object.assign(Object.assign({}, defaultValuesRef.current), (formValues || getFieldsValues(fieldsRef))) : isUndefined(defaultValue)\r\n            ? defaultValuesRef.current\r\n            : isArrayNames\r\n                ? defaultValue\r\n                : { [fieldNames]: defaultValue };\r\n        if (isUndefined(fieldNames)) {\r\n            isGlobal && (isWatchAllRef.current = true);\r\n            return fieldValues;\r\n        }\r\n        const result = [];\r\n        for (const fieldName of convertToArrayPayload(fieldNames)) {\r\n            isGlobal && watchFieldsRef.current.add(fieldName);\r\n            result.push(get(fieldValues, fieldName));\r\n        }\r\n        return isArrayNames ? result : result[0];\r\n    }, []);\r\n    const watch = (fieldName, defaultValue) => isFunction(fieldName)\r\n        ? watchSubjectRef.current.subscribe({\r\n            next: (info) => fieldName(watchInternal(undefined, defaultValue), info),\r\n        })\r\n        : watchInternal(fieldName, defaultValue, true);\r\n    const unregister = (name, options = {}) => {\r\n        for (const inputName of name\r\n            ? convertToArrayPayload(name)\r\n            : Object.keys(fieldsNamesRef.current)) {\r\n            fieldsNamesRef.current.delete(inputName);\r\n            fieldArrayNamesRef.current.delete(inputName);\r\n            if (get(fieldsRef.current, inputName)) {\r\n                if (!options.keepIsValid) {\r\n                    unset(fieldsWithValidationRef.current, inputName);\r\n                    unset(validFieldsRef.current, inputName);\r\n                }\r\n                !options.keepError && unset(formStateRef.current.errors, inputName);\r\n                !options.keepValue && unset(fieldsRef.current, inputName);\r\n                !options.keepDirty &&\r\n                    unset(formStateRef.current.dirtyFields, inputName);\r\n                !options.keepTouched &&\r\n                    unset(formStateRef.current.touchedFields, inputName);\r\n                !shouldUnregister &&\r\n                    !options.keepDefaultValue &&\r\n                    unset(defaultValuesRef.current, inputName);\r\n                watchSubjectRef.current.next({\r\n                    name: inputName,\r\n                    formValues: getValues(),\r\n                });\r\n            }\r\n        }\r\n        formStateSubjectRef.current.next(Object.assign(Object.assign(Object.assign({}, formStateRef.current), (!options.keepDirty ? {} : { isDirty: getIsDirty() })), (resolverRef.current ? {} : { isValid: getIsValid() })));\r\n        !options.keepIsValid && updateIsValid();\r\n    };\r\n    const registerFieldRef = (name, ref, options) => {\r\n        register(name, options);\r\n        let field = get(fieldsRef.current, name);\r\n        const isRadioOrCheckbox = isRadioOrCheckboxFunction(ref);\r\n        if (ref === field._f.ref ||\r\n            (isWeb && isHTMLElement(field._f.ref) && !isHTMLElement(ref)) ||\r\n            (isRadioOrCheckbox &&\r\n                Array.isArray(field._f.refs) &&\r\n                compact(field._f.refs).find((option) => option === ref))) {\r\n            return;\r\n        }\r\n        field = {\r\n            _f: isRadioOrCheckbox\r\n                ? Object.assign(Object.assign({}, field._f), { refs: [\r\n                        ...compact(field._f.refs || []).filter((ref) => isHTMLElement(ref) && document.contains(ref)),\r\n                        ref,\r\n                    ], ref: { type: ref.type, name } }) : Object.assign(Object.assign({}, field._f), { ref }),\r\n        };\r\n        set(fieldsRef.current, name, field);\r\n        const defaultValue = updateValidAndValue(name, options, ref, true);\r\n        if (isRadioOrCheckbox && Array.isArray(defaultValue)\r\n            ? !deepEqual(get(fieldsRef.current, name)._f.value, defaultValue)\r\n            : isUndefined(get(fieldsRef.current, name)._f.value)) {\r\n            get(fieldsRef.current, name)._f.value = getFieldValue(get(fieldsRef.current, name));\r\n        }\r\n    };\r\n    const register = React.useCallback((name, options = {}) => {\r\n        const field = get(fieldsRef.current, name);\r\n        set(fieldsRef.current, name, {\r\n            _f: Object.assign(Object.assign(Object.assign({}, (field && field._f ? field._f : { ref: { name } })), { name, mount: true }), options),\r\n        });\r\n        hasValidation(options, true) &&\r\n            set(fieldsWithValidationRef.current, name, true);\r\n        fieldsNamesRef.current.add(name);\r\n        !field && updateValidAndValue(name, options);\r\n        return isWindowUndefined\r\n            ? { name: name }\r\n            : {\r\n                name,\r\n                onChange: handleChange,\r\n                onBlur: handleChange,\r\n                ref: (ref) => {\r\n                    if (ref) {\r\n                        registerFieldRef(name, ref, options);\r\n                    }\r\n                    else {\r\n                        const field = get(fieldsRef.current, name, {});\r\n                        const shouldUnmount = shouldUnregister || options.shouldUnregister;\r\n                        if (field._f) {\r\n                            field._f.mount = false;\r\n                            // If initial state of field element is disabled,\r\n                            // value is not set on first \"register\"\r\n                            // re-sync the value in when it switched to enabled\r\n                            if (isUndefined(field._f.value)) {\r\n                                field._f.value = field._f.ref.value;\r\n                            }\r\n                        }\r\n                        if (isNameInFieldArray(fieldArrayNamesRef.current, name)\r\n                            ? shouldUnmount && !inFieldArrayActionRef.current\r\n                            : shouldUnmount) {\r\n                            unregisterFieldsNamesRef.current.add(name);\r\n                        }\r\n                    }\r\n                },\r\n            };\r\n    }, []);\r\n    const handleSubmit = React.useCallback((onValid, onInvalid) => async (e) => {\r\n        if (e) {\r\n            e.preventDefault && e.preventDefault();\r\n            e.persist && e.persist();\r\n        }\r\n        let hasNoPromiseError = true;\r\n        let fieldValues = getFieldsValues(fieldsRef);\r\n        formStateSubjectRef.current.next({\r\n            isSubmitting: true,\r\n        });\r\n        try {\r\n            if (resolverRef.current) {\r\n                const { errors, values } = await resolverRef.current(fieldValues, contextRef.current, {\r\n                    criteriaMode,\r\n                    fields: getFields(fieldsNamesRef.current, fieldsRef.current),\r\n                });\r\n                formStateRef.current.errors = errors;\r\n                fieldValues = values;\r\n            }\r\n            else {\r\n                await validateForm(fieldsRef.current);\r\n            }\r\n            if (isEmptyObject(formStateRef.current.errors) &&\r\n                Object.keys(formStateRef.current.errors).every((name) => get(fieldValues, name))) {\r\n                formStateSubjectRef.current.next({\r\n                    errors: {},\r\n                    isSubmitting: true,\r\n                });\r\n                await onValid(fieldValues, e);\r\n            }\r\n            else {\r\n                onInvalid && (await onInvalid(formStateRef.current.errors, e));\r\n                shouldFocusError &&\r\n                    focusFieldBy(fieldsRef.current, (key) => get(formStateRef.current.errors, key), fieldsNamesRef.current);\r\n            }\r\n        }\r\n        catch (err) {\r\n            hasNoPromiseError = false;\r\n            throw err;\r\n        }\r\n        finally {\r\n            formStateRef.current.isSubmitted = true;\r\n            formStateSubjectRef.current.next({\r\n                isSubmitted: true,\r\n                isSubmitting: false,\r\n                isSubmitSuccessful: isEmptyObject(formStateRef.current.errors) && hasNoPromiseError,\r\n                submitCount: formStateRef.current.submitCount + 1,\r\n                errors: formStateRef.current.errors,\r\n            });\r\n        }\r\n    }, [shouldFocusError, isValidateAllFieldCriteria, criteriaMode]);\r\n    const resetFromState = React.useCallback(({ keepErrors, keepDirty, keepIsSubmitted, keepTouched, keepDefaultValues, keepIsValid, keepSubmitCount, }, values) => {\r\n        if (!keepIsValid) {\r\n            validFieldsRef.current = {};\r\n            fieldsWithValidationRef.current = {};\r\n        }\r\n        watchFieldsRef.current = new Set();\r\n        isWatchAllRef.current = false;\r\n        formStateSubjectRef.current.next({\r\n            submitCount: keepSubmitCount ? formStateRef.current.submitCount : 0,\r\n            isDirty: keepDirty\r\n                ? formStateRef.current.isDirty\r\n                : keepDefaultValues\r\n                    ? deepEqual(values, defaultValuesRef.current)\r\n                    : false,\r\n            isSubmitted: keepIsSubmitted ? formStateRef.current.isSubmitted : false,\r\n            isValid: keepIsValid\r\n                ? formStateRef.current.isValid\r\n                : !!updateIsValid(values),\r\n            dirtyFields: keepDirty ? formStateRef.current.dirtyFields : {},\r\n            touchedFields: keepTouched ? formStateRef.current.touchedFields : {},\r\n            errors: keepErrors ? formStateRef.current.errors : {},\r\n            isSubmitting: false,\r\n            isSubmitSuccessful: false,\r\n        });\r\n    }, []);\r\n    const registerAbsentFields = (value, name = '') => {\r\n        const field = get(fieldsRef.current, name);\r\n        if (!field || (field && !field._f)) {\r\n            if (!field &&\r\n                (isPrimitive(value) ||\r\n                    (isWeb && (value instanceof FileList || value instanceof Date)))) {\r\n                set(fieldsRef.current, name, {\r\n                    _f: {\r\n                        ref: { name, value },\r\n                        value,\r\n                        name,\r\n                    },\r\n                });\r\n            }\r\n            if (Array.isArray(value) || isObject(value)) {\r\n                if (name && !get(fieldsRef.current, name)) {\r\n                    set(fieldsRef.current, name, Array.isArray(value) ? [] : {});\r\n                }\r\n                for (const key in value) {\r\n                    registerAbsentFields(value[key], name + (name ? '.' : '') + key);\r\n                }\r\n            }\r\n        }\r\n    };\r\n    const reset = (values, keepStateOptions = {}) => {\r\n        const updatedValues = values || defaultValuesRef.current;\r\n        if (isWeb && !keepStateOptions.keepValues) {\r\n            for (const name of fieldsNamesRef.current) {\r\n                const field = get(fieldsRef.current, name);\r\n                if (field && field._f) {\r\n                    const inputRef = Array.isArray(field._f.refs)\r\n                        ? field._f.refs[0]\r\n                        : field._f.ref;\r\n                    try {\r\n                        isHTMLElement(inputRef) && inputRef.closest('form').reset();\r\n                        break;\r\n                    }\r\n                    catch (_a) { }\r\n                }\r\n            }\r\n        }\r\n        !keepStateOptions.keepDefaultValues &&\r\n            (defaultValuesRef.current = Object.assign({}, updatedValues));\r\n        if (!keepStateOptions.keepValues) {\r\n            fieldsRef.current = {};\r\n            controllerSubjectRef.current.next({\r\n                values: Object.assign({}, updatedValues),\r\n            });\r\n            watchSubjectRef.current.next({\r\n                formValues: Object.assign({}, updatedValues),\r\n            });\r\n            fieldArraySubjectRef.current.next({\r\n                fields: Object.assign({}, updatedValues),\r\n                isReset: true,\r\n            });\r\n        }\r\n        !keepStateOptions.keepDefaultValues &&\r\n            !shouldUnregister &&\r\n            registerAbsentFields(Object.assign({}, updatedValues));\r\n        resetFromState(keepStateOptions, values);\r\n    };\r\n    const setFocus = (name) => get(fieldsRef.current, name)._f.ref.focus();\r\n    React.useEffect(() => {\r\n        !shouldUnregister && registerAbsentFields(defaultValuesRef.current);\r\n        const formStateSubscription = formStateSubjectRef.current.subscribe({\r\n            next(formState) {\r\n                if (shouldRenderFormState(formState, readFormStateRef.current, true)) {\r\n                    formStateRef.current = Object.assign(Object.assign({}, formStateRef.current), formState);\r\n                    updateFormState(formStateRef.current);\r\n                }\r\n            },\r\n        });\r\n        const useFieldArraySubscription = fieldArraySubjectRef.current.subscribe({\r\n            next(state) {\r\n                if (state.fields && state.name && readFormStateRef.current.isValid) {\r\n                    const values = getFieldsValues(fieldsRef);\r\n                    set(values, state.name, state.fields);\r\n                    updateIsValid(values);\r\n                }\r\n            },\r\n        });\r\n        resolverRef.current && readFormStateRef.current.isValid && updateIsValid();\r\n        return () => {\r\n            watchSubjectRef.current.unsubscribe();\r\n            formStateSubscription.unsubscribe();\r\n            useFieldArraySubscription.unsubscribe();\r\n        };\r\n    }, []);\r\n    React.useEffect(() => {\r\n        const isLiveInDom = (ref) => !isHTMLElement(ref) || !document.contains(ref);\r\n        isMountedRef.current = true;\r\n        for (const name of unregisterFieldsNamesRef.current) {\r\n            const field = get(fieldsRef.current, name);\r\n            field &&\r\n                (field._f.refs\r\n                    ? field._f.refs.every(isLiveInDom)\r\n                    : isLiveInDom(field._f.ref)) &&\r\n                unregister(name);\r\n        }\r\n        unregisterFieldsNamesRef.current = new Set();\r\n    });\r\n    return {\r\n        control: React.useMemo(() => ({\r\n            register,\r\n            isWatchAllRef,\r\n            inFieldArrayActionRef,\r\n            watchFieldsRef,\r\n            getIsDirty,\r\n            formStateSubjectRef,\r\n            fieldArraySubjectRef,\r\n            controllerSubjectRef,\r\n            watchSubjectRef,\r\n            watchInternal,\r\n            fieldsRef,\r\n            validFieldsRef,\r\n            fieldsWithValidationRef,\r\n            fieldArrayNamesRef,\r\n            readFormStateRef,\r\n            formStateRef,\r\n            defaultValuesRef,\r\n            fieldArrayDefaultValuesRef,\r\n            unregister,\r\n            shouldUnmount: shouldUnregister,\r\n        }), []),\r\n        formState: getProxyFormState(isProxyEnabled, formState, readFormStateRef),\r\n        trigger,\r\n        register,\r\n        handleSubmit,\r\n        watch: React.useCallback(watch, []),\r\n        setValue: React.useCallback(setValue, [setInternalValues]),\r\n        getValues: React.useCallback(getValues, []),\r\n        reset: React.useCallback(reset, []),\r\n        clearErrors: React.useCallback(clearErrors, []),\r\n        unregister: React.useCallback(unregister, []),\r\n        setError: React.useCallback(setError, []),\r\n        setFocus: React.useCallback(setFocus, []),\r\n    };\r\n}\n\nfunction useWatch(props) {\r\n    const { control, name, defaultValue } = props || {};\r\n    const methods = useFormContext();\r\n    const nameRef = React.useRef(name);\r\n    nameRef.current = name;\r\n    const { watchInternal, watchSubjectRef } = control || methods.control;\r\n    const [value, updateValue] = React.useState(isUndefined(defaultValue)\r\n        ? watchInternal(name)\r\n        : defaultValue);\r\n    React.useEffect(() => {\r\n        watchInternal(name);\r\n        const watchSubscription = watchSubjectRef.current.subscribe({\r\n            next: ({ name: inputName, formValues }) => (!nameRef.current ||\r\n                !inputName ||\r\n                convertToArrayPayload(nameRef.current).some((fieldName) => inputName &&\r\n                    fieldName &&\r\n                    (fieldName.startsWith(inputName) ||\r\n                        inputName.startsWith(fieldName)))) &&\r\n                updateValue(watchInternal(nameRef.current, defaultValue, false, formValues)),\r\n        });\r\n        return () => watchSubscription.unsubscribe();\r\n    }, []);\r\n    return value;\r\n}\n\nexport { Controller, FormProvider, appendErrors, get, set, useController, useFieldArray, useForm, useFormContext, useFormState, useWatch };\n//# sourceMappingURL=index.esm.js.map\n"]},"metadata":{},"sourceType":"module"}